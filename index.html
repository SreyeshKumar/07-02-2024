<html>
	<head>
		<title>201-300</title>
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<b>MSGGFGPA</b>
		<p>Is 4 bytes of hexadecimal foreground presentation attributes. Bytes and
their meaning are:</p>
		<p>Byte 1 - Foreground control field<br/>
Byte 2 - Foreground color field<br/>
Byte 3 - Foreground highlighting field<br/>
Byte 4 - Foreground intensity field</p>
		<p><b>Note:</b> This function has a value only if the message currently being
processed was originally an MDB.</p>
		<b>MSGGMFLG</b>
		<p>GMFLG
Is 2 bytes of MVS general message flags returned as a series of 16, 1
(on) and 0 (off) EBCDIC characters representing the bits in order. Bit
positions and their meaning are:</p>
		<ul>
			<li>Delete operator message (DOM)</li>
		</ul>
		<p><b>Note: </b>This function has a value only if the message currently being
processed was originally an MDB.</p>
		<b>MSGGMID</b>
		<p>A 4-character MVS message identifier. The value of MSGGMID is a
composite of MSGGSEQ and MSGGSYID. MSGGMID might contain
non-displayable characters. This field contains the same information as
SMSGID, except that SMSGID is returned as a decimal number and
MSGGMID is returned as hexadecimal value.</p>
		<b>MSGGSEQ</b>
		<p>A sequence number associated with the message. This value is a 1- to
8-digit decimal number, and is generated from the last 3 bytes of
MSGGMID.</p>
		<b>MSGGSYID</b>
		<p>An ID of the system from which the message was issued. This value is
a 1- to 3-digit decimal number that is generated from the first byte of
MSGGMID.</p>
		<b>MSGGTIME</b>
		<p>A time that MVS associates with the message. An 11-character time in
the form <i>hh:mm:ss:th</i>, where <i>hh</i> is the hours, <i>mm</i> is the minutes, <i>ss</i> is the
seconds, and <i>th</i> is tenths and hundredths of seconds.</p>
		<b>MSGSRCNM</b>
		<p>A 1- to 17-character source name. This source name is an identifier
from the source object that was provided by either the DSIMMDBS or
CNMPMDB API invocation. For more information about DSIMMDBS,
refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler</i>. For more
information about CNMPMDB see “CNMPMDB (CNMPRSMDB):
Process Message Data Block” on page 236.</p>
		<p>The source name is selected from the source object by the following
rules:</p>
		<ul>
			<li>The first nickname, if any</li>
			<li>The first network identifier concatenated to a network addressable
unit (NAU) name, with a period (.) between, if both exist in
sequence</li>
			<li>The first NAU name, if it exists</li>
			<li>The string “N/A” if none of the other names in this list are specified
in the source object</li>
			<li>Null, if there is no source object</li>
		</ul>
		<p>For more information about how the source object is defined, refer to
the DSIAIFRO mapping in <i>IBM Tivoli NetView for z/OS Programming:
Assembler</i>.</p>
		<p><b>Note: </b>This function has a value only if the message currently being
processed was originally an MDB with an associated source object.</p>
		<b>MSGSRCOB</b>
		<p>The entire source object which was provided on the DSIMMDBS or
CNMPMDB application programming interface (API) invocation.<br/>
This value can contain non-displayable characters. The maximum
length that is returned is 1100 bytes. For more information about
DSIMMDBS refer to <i>IBM Tivoli NetView for z/OS Programming:
Assembler</i>. For more information about CNMPMDB, see “CNMPMDB
(CNMPRSMDB): Process Message Data Block” on page 236.</p>
		<b>MSGTOKEN</b>
		<p>A 1- to 10-digit decimal number that indicates the token associated
with the message.<br/>
<b>Usage note: </b>You can use a TOKEN value to group WTOs by setting
MSGTOKEN prior to issuing the WTO command. Subsequently, these
messages can be deleted using a single DOM command by specifying
the token value in MSGTOKEN.<i> Refer to IBM Tivoli NetView for z/OS
Programming: REXX and the NetView Command List Language</i> for
information about DOM token</p>
		<b>MSGTSTMP</b>
		<p>A message time-stamp. The value of this field is the time when the
NetView message buffer was created. The field is a 6-character string
in the form <i>hhmmss:</i></p>
		<ul>
			<li><i>hh</i> is hours</li>
			<li><i>mm</i> is minute</li>
			<li><i>ss</i> is seconds</li>
		</ul>
		<b>MSGTYP</b>
		<p>The system message types flags returned as a series of 3, 1 (on) and 0
(off) EBCDIC characters.<br/>
			The value of the characters are as follows:
		</p>
		<ol>
			<li>SESS (corresponds to IFRAUWF1(14))</li>
			<li>JOBNAMES (corresponds to IFRAUWF1(9))</li>
			<li>STATUS (corresponds to IFRAUWF1(10))</li>
		</ol>
		<b>MVSRTAIN</b>
		<p>In NetView HLL procedures, a 3-bit field describing MVS Retain
characteristics of the message.<br/>
Note: These 3 flags correspond to 3 flags defined in the MVS WQE
control block. The exact meaning and use of the flags is a property of
the operating system. Refer to operating system documentation for
specific information.</p>
		<p><b>1xx</b> AMRF retained message<br/>
			<b>x1x</b> Retain in AMRF<br/>
<b>xx1</b> Do not retain in AMRF
		</p>
		<b>NVDELID</b>
		<p>A NetView message deletion ID. A 24-character EBCDIC value for a
message that can be saved and used later as input to the DOM
command to delete an action message.</p>
		<b>PARTID</b>
		<p>Is the first 2 characters of the 6-character prefix for VSE messages. The
2 returned characters are the message partition ID only if the sending
system uses those characters to designate a partition ID for a message.<br/>
<b>Note: </b>PARTID only has a value if the message originated on a VSE
system.</p>
		<b>PRTY</b>
		<p>A the priority message as set by the originator. This field is a 1- to
5-digit decimal number. NetView does not use this field when
processing the message.<br/>
<b>Note: </b>This function has a value only if the message currently being
processing was originally an MDB.</p>
		<b>REPLYID</b>
		<p>A reply identifier for WTORs. This field has a maximum length of 8
characters.<br/>
For messages from VSE systems, the REPLYID is the last 3 characters
of the 6-character message prefix. The 3 returned characters are the
message reply ID only if the sending system uses those characters to
designate a reply ID for a message.</p>
		<b>ROUTCDE</b>
		<p>Are the MVS routing codes assigned to the message. The value
returned is a series of 1 (on) and 0 (off) EBCDIC characters
representing the bytes in order. The maximum number of ROUTCDEs
assigned to a message is 128.</p>
		<b>SESSID</b>
		<p>A 1- to 8-character ID of the terminal access facility (TAF) session that
sent the message.<br/>
Note: If the TAF session is started with a SESSID that is the same as
the domain ID, the SESSID is set unpredictably and can give
unpredictable results.</p>
		<b>SMSGID</b>
		<p>A 1- to 10-character decimal number that identifies a particular
instance of a message. This function can be used by the DOM
command to identify action messages to be removed from the display.<br/> This field contains the same information as MSGGMID, except that
SMSGID is returned as a decimal number and MSGGMID is returned
as a hexadecimal value.</p>
		<b>SYSCONID</b>
		<p>An MVS system console name associated with the message. System
console names are 2 to 8 characters in length.</p>
		<b>SYSID</b>
		<p>A 1- to 8-character identifier of the MVS system that sent the message.<br/>
SYSID can be used in a sysplex to route commands to the appropriate
system.</p>
		<i>gaqueue</i>
		<p>A 4-byte integer field containing the number of the queue holding the message.
Only attributes for the initial data queue (IDATAQ) can be obtained.</p>
		<i>hlbptr</i>
		<P>A 4-byte pointer field containing the address of the HLB control block.</P>
		
		<b>Usage Notes:</b>
		<ol>
			<li>Other information, which exists in the ORIG_BLOCK, is available when you
call the CNMGETD service routine. See “CNMGETD (CNMGETDATA): Data
queue manipulation” for more information.</li>
			<li>Refer to <i>IBM Tivoli NetView for z/OS Programming: REXX and the NetView
Command List Language</i> for more information.</li>
			<li>Some attributes apply to all types of messages, while others apply only to
certain types of messages. For example, JOBNAME is meaningful only for
messages received from MVS.</li>
		</ol>
		<b>Return Codes:</b>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>The value requested is returned in <i>gadata</i>.</td>
			</tr>
			<tr>
				<td>CNM_DATA_TRUNC</td>
				<td>40</td>
				<td><i>gadatlen</i> was too small. Data truncated.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect <i>ganame</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_QUEUE</td>
				<td>72</td>
				<td>Incorrect <i>gaqueue</i> value</td>
			</tr>
			<tr>
				<td>CNM_QUEUE_EMPTY</td>
				<td>80</td>
				<td>The specified queue is empty.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>gadatlen</i> less than (<) 0.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by gadata is not
addressable.</td>
			</tr>
		</table>
		<h3><b>CNMGETD (CNMGETDATA): Data queue manipulation</b></h3>
		<p>Use the CNMGETD service routine to manipulate input queue data. Input queue
data consists of logical groups of data buffers based on the type of information
about the queue. The types of information that can be placed on the input queues
are:</p>
		<b>Single-line Message</b>
		<p>Contains one data buffer for each logical group. The data buffer contains
the text of the message. The logical group represents the actual message.</p>
		<b>Multiline Message</b>
		<p>Contains one or more data buffers for each logical group. Each data buffer
contains the text from one line of the multiline message. The logical group
represents the actual multiline message.</p>
		<b>Automation MSU</b>
		<p>Contains one or more data buffers for each logical group.</p>
		<b>Reply MSU</b>
		<p>Contains one or more data buffers for each logical group.</p>
		<p>The CNMGETD routine syntax follows:</p>
		<b>PL/I CALL FORMAT:</b>
		<p>CALL CNMGETD<i>(hlbptr,gdfunc,gdbuf,gdbuflen,gdorigin,gdqueue,gdindex)</i></p>
		<b>PL/I MACRO FORMAT:</b>
		<p>CNMGETDATA FUNC(<i>gdfunc</i>) DATA(<i>gdbuf</i>) LENG(<i>gdbuflen</i>)
ORIGIN(<i>gdorigin</i>) QUEUE(<i>gdqueue</i>) LINE(<i>gdindex</i>)</p>
		<b>C INVOCATION</b>
		<p>void Cnmgetd(char *<i>gdfunc</i>, void *<i>gdbuf</i>, int <i>gdbuflen</i>, void *<i>gdorigin</i>,
int <i>gdqueue</i>, int <i>gdindex</i></p>
		<b>Where:</b>
		<i>gdbuf</i>
		<p>A varying length character field containing the data buffer to be returned.<br/>
This field is required for GETFIRST (GETMSG), GETNEXT (GETLINE), and
PEEKBFR (PEEKLINE). It is not required for FLUSHBFR (FLUSHLIN),
FLUSHGRP (FLUSHMSG), or FLUSHQ.</p>
		<i>gdbuflen</i>
		<p>A 4-byte integer field containing the length of <i>gdbuf</i>. This is the maximum
length of the area provided to receive the returned data buffer. You provide the
value for <i>gdbuflen</i>.<br/> This field is required for GETFIRST (GETMSG), GETNEXT (GETLINE), and
PEEKBFR (PEEKLINE).<br/>
If the value specified by <i>gdbuflen</i> is less than the length of the data buffer to be
returned, the truncated data is returned in <i>gdbuf</i> and a return code of
CNM_DATA_TRUNC is generated. The full length of the data buffer that is
truncated is stored in HLBLENG (Hlbleng).<br/>
<b>Note:</b> GETFIRST (GETMSG) and GETNEXT (GETLINE) requests continue to
advance through the queue independent of the truncation. Use a combination
of PEEKBFR (PEEKLINE) with FLUSHBFR (FLUSHLIN), FLUSHGRP
(FLUSHMSG), or FLUSHQ when retrieving complete data buffers of unknown
length.<br/>
If the value specified by <i>gdbuflen</i> is equal to or greater than the length of the
data buffer to be returned, and HLBRC (Hlbrc) = CNM_GOOD, the length of
the returned data buffer is stored in HLBLENG (Hlbleng).<br/>
If the value specified by <i>gdbuflen</i> is greater than the length of the receiving
data buffer (gdbuf), a storage overlay can occur. Take special care when
deciding the value of <i>gdbuflen</i>.</p>	
		<i>gdfunc</i>
		<p>An 8-byte character field that specifies the function to be performed.
Additional field values are provided to support input queue data of any type.
The values support both message and non-message data. The existing
message-related values (GETMSG, GETLINE, and so on) are still supported.</p>
		<b>FLUSHGRP (FLUSHMSG)</b>
		<p>Skips to the next logical group in the specified queue.</p>
		<b>FLUSHNXT (FLUSHLIN)</b>
		<p>Skips over the next data buffer of the specified queue. This function
crosses logical group boundaries until the queue is empty.</p>
		<b>FLUSHQ</b>
		<p>Discards all logical groups in the specified queue.<br/>
<b>Note:</b> If this service is used in a command processor which is driven
by automation, do not flush the initial data queue unless you have
copied the command buffer string to a local variable because the
command buffer is also flushed.</p>
		<b>GETFIRST (GETMSG)</b>
		<p>Returns the first data buffer of the next logical group of buffers on the
specified queue. If one or more buffers of a group have already been
returned by GETFIRST (GETMSG) or GETNEXT (GETLINE), the
current GETFIRST (GETMSG) skips to the next logical group in the
queue, discarding any skipped data buffers.</p>
		<b>GETNEXT (GETLINE)</b>
		<p>Returns the next buffer in the specified queue. This function crosses
logical group boundaries until the queue is empty. Check
ORIG_LINE_TYPE to determine which line is last.</p>
		<b>PEEKBFR (PEEKLINE)</b>
		<p>Returns a data buffer from the logical group at the head of the
specified queue whose buffer number is specified by gdindex. Flushed
and received data buffers can still be obtained unless the logical group
is flushed or a logical buffer in a subsequent logical group was
obtained.</p>
		<i>gdindex</i>
		<p>A 4-byte integer field containing the number (index) of the group at the head
of the queue to be manipulated.<br/>
This field is required only for PEEKBFR (PEEKLINE).</p>
		<i>gdorigin</i>
		<p>A character field of fixed length n (where n > = 38) to contain an origin block.
Define an origin block (gdorigin) to be passed as an operand to CNMGETD.
This must be a separate structure from the origin block (ORIGBLCK) that was
passed to the HLL command processor or installation exit routine as an initial
parameter. ORIG_BLOCK_LENGTH cannot be less than 38. See Appendix A,
“PL/I Control Blocks and Include Files,” on page 269 and Appendix C, “C
language control blocks and include files,” on page 279 for the PL/I and C
mappings of an origin block.<br/>
This field is required for GETFIRST (GETMSG), GETNEXT (GETLINE), and
PEEKBFR (PEEKLINE).</p>
		<i>gdqueue</i>
		<p>A 4-byte integer field containing the number (index) of the queue on which to
perform the operation. This field is required for all functions. Valid values
follow:</p>
		<table>
			<tr>
				<th>Queue
Name</th>
				<th>Queue
Number</th>
				<th>Function</th>
			</tr>
			<tr>
				<td>TRAPQ</td>
				<td>1</td>
				<td>Message queue. Contains trapped messages. See “TRAP
command” on page 182.</td>
			</tr>
			<tr>
				<td>OPERQ</td>
				<td>2</td>
				<td>Operator input queue. See “GO command” on page 177 and
“QUEUE command” on page 178.</td>
			</tr>
			<tr>
				<td>DATAQ</td>
				<td>3</td>
				<td>Data queue. Contains data sent from another HLL command
processor or installation exit routine. See “CNMSMSG
(CNMSENDMSG): Send Message or Command” on page 251.</td>
			</tr>
			<tr>
				<td>IDATAQ</td>
				<td>4</td>
				<td>Initial data queue. Contains the full message or MSU that invokes
the HLL command processor through NetView automation. It also
contains messages that drive DSIEX02A. This is also the queue
where an application command processor receives an MDS-MU
from the NetView high-performance transport, the MS transport,
or operations management for an unsolicited request or
asynchronous reply.</td>
			</tr>
			<tr>
				<td>CNMIQ</td>
				<td>5</td>
				<td>CNMI solicited data queue. Contains RUs solicited through the
CNMI service routine. Chained RUs are treated like multiline
messages. See “CNMCNMI (CNMI): CNMI access under a DST”
on page 189.</td>
			</tr>
			<tr>
				<td>MDSMUQ</td>
				<td>6</td>
				<td>MDS-MU data queue. Contains message units (MUs) received as
synchronous replies. The MDS-MUs are received from operations
management, the MS transport, and the high-performance
transport.</td>
			</tr>
		</table>
		<i>hlbptr</i>
		<p>A 4-byte pointer field containing the address of the HLB control block.</p>
		<b>Usage Notes:</b>
		<ol>
			<li>
				The following items are available after issuing CNMGETD. The NetView
command list language equivalents are listed in the descriptions.
				<b>ORIG_MSG_TYPE</b>
				<p>Provides the 1-character NetView buffer type of the received message
or MSU, and is equivalent to &amp;HDRMTYPE. This control variable
returns a X'10' when an MSU buffer string is being handled.</p>
				<b>ORIG_LINE_TYPE</b>
				<p>Provides the MLWTO line type and is equivalent to &amp;LINETYPE. This
control variable returns the character M for the MSU buffer and an H
for the HIER buffer.</p>
				<b>ORIG_PROCESS</b>
				<p>Is the message identifier of the message currently being processed by
NetView and is equivalent to &amp;MSGID. This control variable returns a
null value when an MSU buffer string is being handled.</p>
				<b>ORIG_DOMAIN</b>
				<p>Is the domain where the message most recently received by NetView
originated and is equivalent to &amp;MSGORIGIN.</p>
			</li>
			<li>See Appendix A, “PL/I Control Blocks and Include Files,” on page 269 and
Appendix C, “C language control blocks and include files,” on page 279 for
mapping of the origin block.
				<b>Return Codes:</b>
			<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_DATA_TRUNC</td>
				<td>40</td>
				<td><i>gdbuflen</i> was too small. Data truncated.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect <i>gdfunc</i> value</td>
			</tr>
			<tr>
				<td>CNM_BAD_QUEUE</td>
				<td>72</td>
				<td>Incorrect <i>gdqueue</i> value</td>
			</tr>
			<tr>
				<td>CNM_BAD_INDEX</td>
				<td>76</td>
				<td>Incorrect <i>gdindex</i> value</td>
			</tr>
			<tr>
				<td>CNM_QUEUE_EMPTY</td>
				<td>80</td>
				<td>The specified queue is empty.</td>
			</tr>
				<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>gdbuflen</i> less than  0.</td>
			</tr>
				<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by either <i>gdbuf</i> or <i>gdorigin</i>
is not addressable</td>
			</tr>
				<tr>
				<td>CNM_NO_LINES_IN_MSG</td>
				<td>264</td>
				<td>All buffers in the specified logical group have
been deleted.</td>
			</tr>
		</table>
				</li>
		</ol>
		<h3><b>CNMHRGS (CNMHREGIST): high-performance transport
application registration</b></h3>
		<p>The CNMHRGS service routine registers any application that wants to send data to
or receive data from another application through the high-performance transport
API. Register the application before attempting to send or receive data.<br/>
CNMHRGS also deregisters applications, which results in the termination of the
high-performance transport’s awareness of the application. After deregistration, the
application cannot send or receive any further data.<br/>
The CNMHRGS routine syntax follows:</p>
		<b>PL/I CALL FORMAT:</b>
		<p>CALL CNMHRGS(<i>hlbptr,hrtype,hrappl,hrcmd,hrlogmod,hrrepl,hrnotify,hrpri</i>)</p>
		<b>PL/I MACRO FORMAT:</b>
		<p>CNMHREGIST TYPE(<i>hrtype</i>) APPL(<i>hrappl</i>) COMMAND(<i>hrcmd</i>)
LOGMODE(<i>hrlogmod</i>) REPLACE(<i>hrrepl</i>) NOTIFY(<i>hrnotify</i>)
PRI(<i>hrpri</i>)</p>
		<b>C INVOCATION:</b>
		<p>void Cnmhrgs(char *<i>hrtype</i>, char *<i>hrappl</i>, char *<i>hrcmd</i>,
char *<i>hrlogmod</i>, char *<i>hrrepl</i> char *<i>hrnotify</i>,
char *<i>hrpri</i>)</p>
		<i><b>Where</b></i>
		<i>hlbptr</i>
		<p>A 4-byte pointer field containing the address of the HLB control block.</p>
		<i>hrappl</i>
		<p>An 8-byte character field that specifies the application to be registered or
de-registered.<br/>
The identifier name can be one of:</p>
		<ul>
			<li>
				<p>An architecturally defined 4-byte value (padded with blanks to 8 bytes) for
high-performance application programs.<br/>
The following names are reserved by NetView and cannot be specified in a
CNMHRGS invocation:</p>
				<b>ALERT</b>
				<p>X'23F0F3F1'</p>
				<b>EP_OPS</b>
				<p>X'23F0F1F6'</p>
				<b>EP_SPCS</b>
				<p>X'23F0F1F4'</p>
				<b>LINKSERV</b>
				<p>X'23F0F3F5'</p>
				<b>MDS_RECEIVE</b>
				<p>X'23F0F0F1'</p>
				<b>MDS_ROUTER</b>
				<p>X'23F0F1F0'</p>
				<b>MS_CAPS</b>
				<p>X'23F0F1F1'</p>
				<b>OPS_MGMT</b>
				<p>X'23F0F1F7'</p>
				<b>R_BRIDGE</b>
				<p>X'30F0F5F9'</p>
				<b>RTMCMD_O</b>
				<p>X'30F0F7F2'</p>
				<b>RMTCMD_R</b>
				<p>X'30F0F5F5'</p>
				<b>RTMCMD_S</b>
				<p>X'30F0F7F0'</p>
				<b>SPCS</b>
				<p>X'23F0F1F5'</p>
				<h4><b>No character equivalent</b></h4>
				<p>X'30F0F7F3'</p>
				
			</li>
			<li>
				A 1–8 character installation-defined name (padded with blanks). Use the
EBCDIC characters 0–9 and A-Z (capitals only).
The name STATUS is reserved for the NetView status focal point and is not
allowed on a CNMHRGS invocation.
				<i>hrcmd</i>
				<p>An 8-byte character field that specifies the command processor that is started
when unsolicited or asynchronous data is routed to the application. The
NetView program verifies that the task is authorized to issue the command
specified on <i>hrcmd</i>. This field is required for REGAPPL.</p>
				<i>hrlogmod</i>
				<p>An 8-byte character field that specifies the logmode that is used for sending
the application data. This name must be a logmode that is defined to the local
VTAM and the receiving LU or command processor (CP) with which this
application communicates.<br/>
<b>Note: </b><i>hrlogmod</i> is used only on the initial registration request for an
application. You cannot change a registered application’s logmode unless you
deregister the application.</p>
				<i>hrnotify</i>
				<p>An 8-byte character field that specifies whether the MS or operations
management served application receives session outage notification for LUs in
contact with the LU 6.2 sessions.</p>
				<b>ALL</b>
				<p>Indicates that the application receives an MDS-MU containing an SNA
condition report with sense data every time the last SNASVCMG
session has been lost. This notification is received even if the session
outage is not related to an error.</p>
				<b>ERROR</b>
				
				<p>Indicates that the application receives an MDS-MU containing an SNA
condition report with sense data every time the last SNASVCMG
session has been lost because of session failure</p>
				<b style="text-decoration: underline">NONE</b>
				<p>Indicates that the application does not receive session outage
notification. NONE is the default for the PL/I macro format.</p>
			</li>
		</ul>
		<p>If you do not specify the NOTIFY keyword when using the PL/I macro
format, the default value is used. Otherwise, this field is required.</p>
		<i>hrpri</i>
		<p>An 8-byte character field that specifies the MQS priority for incoming requests.
The MQS priority is used when the high-performance transport uses the MQS
for processing any unsolicited MDS-MUs.</p>
		<b>HIGH</b>
		<p>Processing begins after any NORMAL requests currently in progress
completes, but before queued NORMAL or LOW requests.</p>
		<b style="text-decoration: underline">LOW</b>
		<p>Processing is preempted by HIGH and NORMAL priority requests.
This is the default.</p>
		<b>NORMAL</b>
		<p>Processing preempts a queue of LOW priority requests.</p>
		<b>TEST</b>
		<p><i>CNMHRGS</i> queues the request based on the command priority of the
receiving task. The command priority can be set using the OVERRIDE
or DEFAULT commands. Refer to the <i>IBM Tivoli NetView for z/OS
Command Reference</i> for more information.</p>
		<i>hrrepl</i>
		<p>A 4-byte character field that specifies whether this registration is to supersede
any previous registration for this application.</p>
		<b>NO</b>
		<p>Specifies that this registration does not replace the current registration
for this application.</p>
		<b style="text-decoration: underline" >YES</b>
		<p>Specifies that this registration replaces the current registration for this
application. YES is the default for the PL/I macro format.</p>
		<p>This is a required field for REGAPPL. However, if you do not specify the
REPLACE keyword in the PL/I macro format, the default value is used.</p>
		<i>hrtype</i>
		<p>A 10-byte character field that specifies the type of request:</p>
		<b>DEREGAPPL</b>
		<p>Deregisters an application from the high-performance transport.</p>
		<b>REGAPPL</b>
		<p>Registers an application to the high-performance transport.</p>
		
		<b>Usage Notes:</b>
		<ol>
			<li>If you specify a logmode that is not defined in the logmode table, VTAM
defaults the logmode to the first entry in the logmode table.</li>
			<li>
				The NetView task where an application receives an MDS-MU is determined as
follows:
				<ul>
					<li>For an MDS reply, the receiving task is the task under which the requesting
application was running.</li>
					<li>For an MDS request, the receiving task is the task from which CNMHRGS is
started for the receiving application.</li>
					<li>For an MDS error message:
					<ul style="list-style-type: square;">
						<li>If the agent unit of work correlator (AUOWC) matches an active AUOWC
in the active transaction list:</li>
						<li>For an outgoing request, the receiving task is the task under which the
requesting application was running.</li>
						<li>For an incoming request, the receiving task is the task under which the
receiving application was running.</li>
						<li>If the AUOWC does not match an active AUOWC, the receiving task is
the task from which CNMHRGS is started for the receiving application.</li>
						</ul></li>
				</ul>
			</li>
			<li>You can change the task under which CNMHRGS was started by registering
the application from the desired task and specifying YES for <i>hrrepl</i>.</li>
		</ol>
		
		
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Successful registration/deregistration.</td>
			</tr>
			<tr>
				<td>CNM_NOT_FOUND</td>
				<td>20</td>
				<td>Deregistration unsuccessful. hrappl not registered..</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Registration unsuccessful. No storage
available.</td>
			</tr>
			<tr>
				<td>CNM_NOT_IN_ASYNCH</td>
				<td>44</td>
				<td>Deregistration unsuccessful. Issued from an
installation exit.</td>
			</tr>
			<tr>
				<td>CNM_DUPL_NAME</td>
				<td>104</td>
				<td>Registration unsuccessful. hrappl already
registered.</td>
			</tr>
			<tr>
				<td>CNM_BUSY</td>
				<td>472</td>
				<td>Registration/deregistration unsuccessful.
Queues are in use.</td>
			</tr>
				<tr>
				<td>CNM_BAD_APPL_NAME</td>
				<td>476</td>
				<td>Registration/deregistration unsuccessful.
<i>hrappl</i> syntax incorrect.</td>
			</tr>
				<tr>
				<td>CNM_APPL_NAME_RSTD</td>
				<td>480</td>
				<td>Registration/deregistration unsuccessful.
<i>hrappl</i> restricted.</td>
			</tr>
				<tr>
				<td>CNM_BAD_REG_TYPE</td>
				<td>492</td>
				<td>Incorrect <i>hrtype</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_REPLACE_VALUE</td>
				<td>504</td>
				<td>Incorrect <i>hrtype</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LOGMODE</td>
				<td>580</td>
				<td>Registration unsuccessful, hrlogmod does not
match the existing logmode for <i>hrtype</i>.</td>
			</tr>
			<tr>
				<td>CNM_LOGMODE_REQUIRED</td>
				<td>584</td>
				<td>Registration unsuccessful. A value for hrlogmod
is required.</td>
			</tr>
			<tr>
				<td>CNM_BAD_NOTIFY</td>
				<td>592</td>
				<td>Incorrect <i>rgnotify</i> value specified.</td>
			</tr>
			<tr>
				<td>CNM_BAD_CES + X</td>
				<td>900 + X</td>
				<td>Registration unsuccessful. Nonzero return
code, X, from DSICES macro using <i>hrcmd</i>.</td>
			</tr>
		</table>
		
		<h3><b>CNMHSMU (CNMHSENDMU): Send high-performance message
unit</b></h3>
		<p>The CNMHSMU service routine enables NetView applications to send data to a
specified target through the high-performance transport API. The high-performance
transport uses an LU 6.2 conversation, and VTAM selects the appropriate session
for the actual transmission. You can invoke CNMHSMU only in applications
registered through CNMHRGS or the REGISTER command.<br/>
The data is sent in the form of an MDS-MU. You can supply:</p>
		<ul>
			<li>A completely built MDS-MU</li>
			<li>An MDS-MU that is missing one or more of:<br/>
				– A unit of work correlator (UOWC)<br/> – An origin NETID<br/>
– An origin LUNAME
			</li>
			<li>A GDS variable that can be contained in an MDS-MU, and can supply sufficient
other fields for the service routine to build an MDS-MU header.</li>
			
			
		</ul>
		<p>Refer to the SNA library for more information about MDS-MUs and GDS variables.>br/>
The CNMHSMU service routine builds the necessary NetView MQS buffer with
the specified data and queues it to the high-performance transport.<br/>
The CNMHSMU routine syntax follows:</p>
		<b>PL/I CALL FORMAT:</b>
		<p>CALL CNMHSMU<i>(hlbptr,hsdtype,hsdata,hssupcor,hscorrar, hstimout,hssynch,hsrplcmd,
hsoappl,hsdstnet,hsdstlu,hsdstapl,hsmutype,hspri</i>)</p>
		<b>PL/I MACRO FORMAT:</b>
		<p>CNMHSENDMU DATATYPE(<i>hsdtype</i>) DATA(<i>hsdata</i>) SUPPCORREL(<i>hssupcor</i>)<br/>
CORRELAREA(<i>hscorrar</i>) TIMEOUT(<i>hstimout</i>) SYNCH(<i>hssynch</i>)<br/>
REPLYCMD(<i>hsrplcmd</i>) ORIGAPPL(<i>hsoappl</i>)<br/>
DESTNET(<i>hsdstnet</i>) DESTLU(<i>hsdstlu</i>) DESTAPPL(<i>hsdstapl</i>)<br/>
MUTYPE(<i>hsmutype</i>) PRI(<i>hspri</i>)</p>
		<b>C INVOCATION:</b>
		<p>void Cnmhsmu(char *<i>hsdtype</i>, void *<i>hsdata</i>, void *<i>hssupcor</i>,
void *<i>hscorrar</i>, int <i>hstimout</i>, char *<i>hssynch</i>,
char *<i>hsrplcmd</i>, char *<i>hsoappl</i>, char *<i>hsdstnet</i>,
char *<i>hsdstlu</i>, char *<i>hsdstapl</i>, int <i>hsmutype</i>,
char *<i>hspri</i>) </p>
		<i><b>where</b></i>
		<i>hlbptr</i>
		<p>A 4-byte pointer field containing the address of the HLB control block.</p>
		<i>hscorrar</i>
		<p>A 53-byte character field in which a new unit of work correlator (X'1549') GDS
variable is created and returned by the CNMHSMU service routine.<br/>
If you specify hscorrar for an MDSMU, NetView creates the unit of work
correlator in this area and inserts it into the specified MDS-MU while copying
it into the buffer for the high-performance transport. If you omit <i>hscorrar</i>, the
MDS-MU must be complete and ready to be transmitted as supplied.
		For a NONMDSMU, specify either <i>hscorrar</i> or <i>hssupcor</i>. If you specify hscorrar, <i>CNMHSMU</i> creates the unit of work correlator GDS variable in this area and
uses it in building the MDS header. If you specify both hssupcor and hscorrar, hssupcor is used.</p>
		<i>hsdata</i>
		<p>A varying length character field containing the data being sent. For either
MDSMU or NONMDSMU the first 2 bytes must contain the entire length of
the data and the next 2 bytes must contain the key.</p>
		<i>hsdstapl</i>
		<p>An 8-byte character field that specifies the destination high-performance
application name.
		The application name can be one of:</p>
		<ul>
			<li>v An architecturally defined 4-byte value (padded with blanks to 8 bytes) for
MS application programs.</li>
			<li>A 1–8 character installation-defined name (padded with blanks). Use the
EBCDIC characters 0–9 and A-Z (capitals only).</li>
			<li>A 1–8 character NetView-reserved name (padded with blanks) that
represents an architecturally defined 4-byte value. The NetView-defined
names and their corresponding values follow:</li>
		</ul>
		<b>ALERT</b>
		<p>X'23F0F3F1'</p>
		<b>EP_ALERT</b>
		<p>X'23F0F3F0'</p>
		<b>EP_OPS</b>
		<p>X'23F0F1F6'</p>
		<b>MS_CAPS</b>
		<p>X'23F0F1F1'</p>
		<b>OPS_MGMT</b>
		<p>X'23F0F1F7'</p>
		
		<p>This field is required for NONMDSMU.</p>
		
		<i>hsdstlu</i>
		<p>An 8-byte character field that specifies the LU name of the destination LU.
Specify the 1–8 character LU name (padded with blanks to 8 characters)
beginning with an EBCDIC character 0–9 and A-Z (capitals only), @, #, or $,
and followed by EBCDIC characters 0–9 and A-Z (capitals only).<br/>
This field is required for NONMDSMU.</p>
		<i>hsdstnet</i>
		<p>An 8-byte character field that specifies the ID of the network of the destination
LU. Specify the 1-8 character NETID (padded with blanks to 8 characters)
beginning with an EBCDIC character, @, #, or $, and followed by EBCDIC
characters 0–9 and A-Z (capitals only). The value of this field defaults to the
network name that VTAM determines based on the LU name of the remote
node (specified with the hsdstlu field) if you:</p>
		<ul>
			<li>Specify blanks for this field for the PL/I call format.</li>
			<li>Do not specify the DESTNET keyword when using the PL/I macro format.</li>
			<li>Specify blanks for this field for the C invocation format.</li>
		</ul>
		<i>hsdtype</i>
		<p>An 8-byte character field indicating whether the data item specified with the
hsdata field is an MDS-MU or a non-MDS-MU.</p>
		<b style="text-decoration: underline">MDSMU</b>
		<p>Indicates that the hsdata is an MDS-MU. MDSMU is the default for the
PL/I macro format.</p>
		<b>NONMDSMU</b>
		<p>Indicates that the hsdata is not a complete MDS-MU because it does not
contain an MDS-MU header. The CNMHSMU service routine
envelopes this data in an MDS-MU header before sending it.</p>
		<p>If you do not specify the DATATYPE keyword when using the PL/I macro
format, the default value is used.</p>
		<i>hsmutype</i>
		<p>A 4-byte integer field that specifies the index number that identifies the type of
MDS-MU to build. The type identifies whether the MDS-MU is a request, a
reply, or an error message, and whether additional messages are expected. The
following types are defined as constants:</p>
		<ol>
			<li>REQUEST_WITH_REPLY</li>
			<li>REQUEST_WITHOUT_REPLY</li>
			<li>REPLY_ONLY</li>
			<li>REPLY_NOTLAST</li>
			<li>REPLY_LAST</li>
			<li>ERROR_MESSAGE</li>
		</ol>
		<p>This is a required keyword for NONMDSMU.</p>
		<i>hsoappl</i>
		<p>An 8-byte character field that specifies the origin high-performance application
name.</p>
		<p>The application name can be one of the following values:</p>
		<ul>
			<li>An architecturally defined 4-byte value (padded with blanks to 8 bytes) for
high-performance application programs.</li>
			<li>A 1-8 character installation-defined name (padded with blanks). Use the
EBCDIC characters 0–9 and A-Z (capitals only).</li>
			
		</ul>
		<p>This field is required for NONMDSMU.</p>
		<i>hspri</i>
		<p>An 8-byte character field that specifies the MQS priority for incoming solicited
requests or any MDS error messages resulting from any outgoing MDS-MUs.
The MQS priority is used when the high-performance transport uses the MQS
for processing any solicited MDS-MUs or any MDS error messages.</p>
		<b>HIGH</b>
		<p>Processing begins after any NORMAL requests currently in progress
completes, but before queued NORMAL or LOW requests.</p>
		<b>LOW</b>
		<p>Processing is preempted by HIGH and NORMAL priority requests.
This is the default for all requests other than synchronous requests.</p>
		<b>NORMAL</b>
		<p>Processing preempts a queue of LOW priority requests. This is the
default for synchronous requests</p>
		<b>TEST</b>
		<p>CNMHSMU queues the request based on command priority of the
receiving task. The command priority can be set using the OVERRIDE
or DEFAULT commands. Refer to the IBM Tivoli NetView for z/OS
Command Reference for more information.</p>
		<i>hsrplcmd</i>
		<p>An 8-byte character field containing the name of the command to be driven
with the reply. The hsrplcmd field is used only in an application that is sending
REQUEST_WITH_REPLY with the reply being received asynchronously. Otherwise, it is ignored.<br/>
This is an optional field. The default is the registered command for the
invoking application.</p>
		<i>hssupcor</i>
		<p>A varying length character field containing a complete unit of work correlator
(X'1549') GDS variable. The hssupcor field must contain a 2-byte length, a 2-byte
key, and at least 1 byte of correlator data. Refer to the SNA library for more
information about defining the correlator.<br/> <i>hssupcor</i> is not valid for an MDS-MU. For a NONMDSMU, specify either
hssupcor or hscorrar. If you specify hssupcor, the supplied value is used to build
the MDS header. No validity checking is done for a correlator supplied by the
invoker.</p>
		<i>hssynch</i>
		<p>An 8-byte character field that specifies whether the high-performance
application is to receive the reply synchronously</p>
		<b style="text-decoration: underline;" >NO</b>
		<p>Indicates that the reply is received asynchronously. NO is the default
for the PL/I macro format.</p>
		<b>NO_BUF</b>
		<p>Do not suspend the application but buffer replies until the last is
received. This value is equivalent to the NO value.</p>
		<b>NO_UNBUF</b>
		<p>Do not suspend the application and forward replies immediately.</p>
		<b>YES</b>
		<p>Indicates that the reply is received synchronously.</p>
		<b>YES_BUF</b>
		<p>Suspend the applicat</p>
		
		<p>If you do not specify the SYNCH keyword when using the PL/I macro format
for REQUEST_WITH_REPLY, the default value is used. Otherwise, the field is
required for REQUEST_WITH_REPLY.</p>
		<i>hstimout</i>
		<p>A 4-byte integer field that specifies the number of seconds to wait for the reply
of an outstanding REQUEST_WITH_REPLY. For a REQUEST_WITH_REPLY
that generates multiple replies, the timeout value applies only to the last reply.<br/> The NetView program initializes default and maximum timeout values for the
LU 6.2 transport send services. The initial default and maximum timeout
values are 120 and 86400 seconds, respectively. You can change these values
with the DEFAULTS command.<br/>
The valid values for hstimout are:</p>
		<p><b>1 ... X</b>
Where X is the maximum timeout value.</p>
		<p><b>0</b> Indicates the default timeout value.</p>
		<p><b>-1</b> Indicates the maximum timeout value.</p>
		
		<p>If you do not specify the SECONDS keyword when using the PL/I macro
format for REQUEST_WITH_REPLY, the default timeout value is used.
Otherwise, this field is required for REQUEST_WITH_REPLY.</p>
		<b>Usage Notes:</b>
		<ol>
			<li>For a synchronous REQUEST_WITH_REPLY, control is returned to the
invoking program after the last reply, or an error message is received and
placed on the MDSMUQ data queue. Otherwise, control is returned after
CNMHSMU successfully queues the request to the high-performance
transport.</li>
			<li>When the invoking program is suspended because of a synchronous
REQUEST_WITH_REPLY, the NetView task where the program is running is
not suspended. The task still receives and processes messages and commands.</li>
			<li>For a synchronous REQUEST_WITH_REPLY from a DST, a DSRB is marked
in-use and the DSRB is not available for other use until the suspended
program is started again.</li>
			<li>For MDSMU, all fields within the MDS-MU header must be correct except for
origin NETID and LUNAME. The service routine can determine and set these
fields. If the correlator is not contained in the data, specify <i>hscorrar</i>.</li>
			<li>For REPLY_ONLY, REPLY_NOTLAST, REPLY_LAST, and ERROR_MESSAGE,
specify <i>hssupcor</i> to return the correlator sent with the request.</li>
			<li>The high-performance transport implements a timeout value for the
application receiving the data. If the invocation of CNMHSMU specifies a
timeout value greater than the timeout value set by the transport at the
receiving node, the sending application might time out in less than the
specified interval.</li>
			<li>When VTAM is active, you can use CNMHSMU to send data to another
application in the same domain.</li>
			<li>If <i>hsdstnet</i> is not the NETID determined by VTAM for the LU specified in
<i>hsdstlu</i>, the send fails.</li>
			<li>A high-performance application cannot send data to itself within the same
NetView.</li>
			<li>A return code 24 or 28 from DSIPUSH indicates that DSIOLGFP is not defined
correctly in DSIPARM member CNMCMD.</li>
			<li>If CNM_BAD_CES is returned:
				<ul>
					<li>Verify that DSI6SNDP is defined correctly in member CNMCMD.</li>
					<li>If you specify hrrepcmd, verify that it is defined correctly in member
CNMCMD.</li>
					<li>If you specify a synchronous REQUEST_WITH_REPLY, verify that
DSIOSRCP is defined correctly in member CNMCMD.</li>
				</ul>
			</li>
			<li>Refer to the <i>IBM Tivoli NetView for z/OS Administration Reference</i> for the correct
definitions of the command processors supplied by the NetView product.</li>
			<li>For MDSMU, if you omit the NETID subfield of the destination subvector
from the MDS-MU header, VTAM determines the network name used, based
on the LU name in the NAU name subfield of the destination subvector.</li>
			<li>If you do not specify the destination NETID, and the destination LU name
exists in more than one network, VTAM determines the destination NETID
based on the active configuration.</li>
		</ol>
		
		<b>Return Codes:</b>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_BAD_INVOCATION</td>
				<td>4</td>
				<td>Task is ending, TVBABEND/
TVBLOGOF is on.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>No storage is available.</td>
			</tr>
			<tr>
				<td>CNM_NOT_IN_ASYNCH</td>
				<td>44</td>
				<td>Send MU service is started from an
installation exit.</td>
			</tr>
			<tr>
				<td>CNM_BAD_TIMEOUT</td>
				<td>56</td>
				<td>Timeout value is not valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td>MDS-MU length is not valid.</td>
			</tr>
				<tr>
				<td>CNM_TASK_INACTIVE</td>
				<td>220</td>
				<td>DSIHPDST not active.</td>
			</tr>
				<tr>
				<td>CNM_BAD_DATA_TYPE</td>
				<td>400</td>
				<td>Data type is not valid.</td>
			</tr>
				<tr>
				<td>CNM_BAD_DATA</td>
				<td>404</td>
				<td>Data missing or is not valid.</td>
			</tr>
			<tr>
				<td>CNM_SAME_APPL</td>
				<td>408</td>
				<td>Application cannot send data to the
same application within the same
NetView program.</td>
			</tr>
			<tr>
				<td>CNM_SYNCH_NOT_COMP</td>
				<td>412</td>
				<td>SYNCH(YES) is not allowed under a
NetView installation exit or the PPT.</td>
			</tr>
			<tr>
				<td>CNM_OAPPL_NOT_REG</td>
				<td>416</td>
				<td>Application is not registered.</td>
			</tr>
			<tr>
				<td>CNM_BAD_UOW</td>
				<td>424</td>
				<td>UOW is missing or not valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_OAPPL</td>
				<td>440</td>
				<td>Origin application name is not valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_DNETID</td>
				<td>444</td>
				<td>Destination network ID missing or is
not valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_DLU</td>
				<td>448</td>
				<td>Destination LU name is not valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_DAPPL</td>
				<td>452</td>
				<td>Destination application name is not
valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_REPLY</td>
				<td>460</td>
				<td>Reply is not valid.</td>
			</tr>
			<tr>
				<td>CNM_BAD_MUTYPE</td>
				<td>464</td>
				<td>Bad MUTYPE given.</td>
			</tr>
			<tr>
				<td>CNM_BAD_SYNCH</td>
				<td>468</td>
				<td>Bad SYNCH option.</td>
			</tr>
			<tr>
				<td>CNM_BUSY</td>
				<td>472</td>
				<td>User list is full.</td>
			</tr>
			<tr>
				<td>CNM_SYNCH_CMD_MISSING</td>
				<td>508</td>
				<td>SYNCH(YES) is specified but
DSIOSRCP or DSIOLGFP is not defined
or is not defined correctly in DSIPARM
member CNMCMD.</td>
			</tr>
			<tr>
				<td>CNM_REQ_CANCELED</td>
				<td>552</td>
				<td>Synchronous request cancelled by user.</td>
			</tr>
			<tr>
				<td>CNM_TASK_NO_AUTH</td>
				<td>556</td>
				<td>Task does not have authorization to run
the registered command associated with
the origin application name.</td>
			</tr>
			<tr>
				<td>CNM_SNACR_MISSING</td>
				<td>588</td>
				<td>SNA condition report (X'1532') is
missing from the MDS error message.</td>
			</tr>
			<tr>
				<td>CNM_NETID_UNINIT</td>
				<td>596</td>
				<td>NETID is not initialized.</td>
			</tr>
			<tr>
				<td>CNM_BAD_MQS + X</td>
				<td>1000 + X</td>
				<td>Nonzero return code, X, from DSIMQS macro</td>
			</tr>
			<tr>
				<td>CNM_BAD_PUSH + X</td>
				<td>4000 + X</td>
				<td>X is the return code from DSIPUSH.</td>
			</tr>
			<tr>
				<td>CNM_BAD_CES + X</td>
				<td>9000 + X</td>
				<td>Nonzero return code, X, from DSICES macro.
</td>
			</tr>
		</table>
		<p>Refer to<i> IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.</p>
		<h3><b>CNMINFC (CNMINFOC): Query NetView Character Information</b></h3>
		<p>
			The CNMINFC service routine allows you to obtain information about the current
NetView environment. CNMINFC returns character data.<br/>
The CNMINFC routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMINFC (<i>hlbptr,icname,icdata,icdatlen</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMINFOC ITEM(icname) DATA(icdata) LENG(icdatlen)<br/>
<b>C INVOCATION:</b><br/>
void Cnminfc(char *<i>icname</i>, void *<i>icdata</i>, int <i>icdatlen</i>)<br/>
<b>Where:</b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>icdata</i><br/>
Is a varying length character field containing the character data to be returned.
<i>icdatlen</i><br/>
Is a 4-byte integer field containing the length of icdata. This is the maximum
length of the area provided to receive the returned data. You provide the value
of icdatlen. This field must be greater than 0 and less than 32729.<br/>
If the value specified by icdatlen is less than the length of the data to be
returned, the truncated data is returned in icdata and a return code of
CNM_DATA_TRUNC is generated. The full length of the data that was
truncated is stored in HLBLENG (<i>Hlbleng</i>).<br/>
If the value specified by icdatlen is equal to or greater than the length of the
data to be returned, and HLBRC (<i>Hlbrc</i>) = CNM_GOOD, the length of the
returned data is stored in HLBLENG (<i>Hlbleng</i>).<br/>
If the value specified by icdatlen is greater than the length of the receiving data
buffer (icdata), a storage overlay can occur.<br/> 
			<i>icname</i><br/>
Is an 8-byte character field that specifies the name of a variable. Valid names
are:<br/>
<b>APPLID</b><br/>
Is the NetView domain ID appended with a 3-character alphanumeric
value assigned by the NetView program.<br/>
<b>AUTCONID</b><br/>
Is the MVS console identifier associated with this autotask. This
association was made using the AUTOTASK command with the
console keyword. This value of AUTCONID is the console name of the
MVS console where NetView commands can be entered to run under
this autotask.<br/>
<b>CLOCK</b><br/>
Is the current value returned by STCK instruction (not displayable).<br/>
			<b>CURCONID</b><br/>
Is the MVS console obtained by a NetView task. This console was
obtained with the GETCONID command or by issuing an MVS
command. The value of CURCONID is the console name of the MVS
console that this task uses to enter MVS commands.<br/>
<b>CURSYS</b><br/>
Is a 1- to 8-character name of the current operating system.<br/>
<b>DATE</b> Is the current date in the form of mm/dd/yy, where mm is the month, dd
is the day, and <i>yy</i> is the year.<br/> <b>DATETIME</b><br/>
Equivalent to &amp;DATE followed by &amp;TIME.<br/>
<b>DATETIM2</b><br/>
Is the date and time in the YYYYMMDD HH:MM:SS format.<br/>
<b>DOMAIN</b><br/>
Is the 1- to 5-character name of the current NetView domain.<br/>
<b>ECVTPSEQ</b>
Is the z/OS product sequence number found in the MVS IHAECVT
data area.<br/>
<b>HCOPY</b><br/>
Is the name of the device defined as the hardcopy log printer started
by the operator. If there is no device defined as the hardcopy printer
for this operator, HCOPY is null.<br/>
<b>IPV6</b> Indicates the IPv6Env setting in the CNMSTYLE member:<br/>
<b>4</b> Indicates that the IPv6Env statement is set to NONE.<br/>
<b>6</b> Indicates that the IPv6Env statement is set to ONLY.<br/> <b>M</b> Indicates that the IPv6Env statement is set to MIXED.<br/>
<b>LU</b> Is the logical unit name for the operator terminal.<br/>
<b>MVSLEVEL</b><br/>
Is the currently running version of MVS.<br/>
<b>NETID</b><br/>
Is the VTAM network identifier. This field has a maximum length of 8
characters.<br/>
<b>Note: </b>If VTAM has never been active while NetView is active, the
value is assigned from the NETID statement in the CNMSTYLE
member.<br/> <b>NVVER</b><br/>
Is the version and release of the currently running NetView program.
The value of NVVER is a 4-character string in the form of NV<i>vr</i>, where:<br/>
<b>NV</b> Indicates NetView.<br/> <i>v</i> Indicates the version number of NetView.<br/> <i>r</i> Indicates the release number of NetView.<br/> <b>OPID</b><br/> Is the operator or task ID that issued the call to CNMINFC. OPID is a
1- to 8-character identifier.<br/>
				
<b>OPSYSTEM</b><br/>
Is the operating system for which NetView was compiled, and the HLL
command processor or installation exit routine is running. OPSYSTEM
must be MVS/ESA.<br/>
<b>OWNER</b><br/>
Is the operator ID of the task that owns the VOST. Note that data is
only returned for VOST tasks.<br/>
<b>PID</b> The process ID for this HLL command processor or installation exit
routine. Used for CNMSMSG with smmsgtyp=DATA (not displayable).<br/>
<b>STARTIME</b><br/>
The NetView start time (not displayable).<br/>
<b>SUPPCHAR</b><br/>
Is the 1-character NetView suppression character.<br/> <b>SYSPLEX</b><br/>
Is the 1- to 8-character name of the MVS SYSPLEX where the
command list is executing.<br/>
<b>Note:</b> This function has a value only if the command list is executing
on an MVS SYSPLEX or on an MVS system that specified a sysplex
name in a couple data set.<br/>
<b>TASK</b> Is a character string indicating the type of task under which the
command processor or installation exit routine is running. Possible
values follow:<br/>
<b>DST</b> Data Services Task<br/>
<b>HCT</b> Hardcopy Task<br/>
<b>MNT</b> Main Task<br/>
<b>NNT</b> NetView-to-NetView Task<br/>
<b>OPT</b> Optional Task<br/>
<b>OST</b> Operator Station Task<br/>
<b>PPT</b> Primary POI Task<br/>
<b>UNKNOWN</b><br/>
None of the above.
<b>TASKNAME</b><br/>
The name of the task under which the HLL command processor or
installation exit routine is running.<br/>
<b>TIME</b> Is the CPU time in the form of hh:mm, where hh is the hour and mm is
the minutes. The time is based on a 24-hour clock, so 3:00 P.M. is
shown as 15:00.<br/>
<b>VTAM</b><br/>
Is the version and release of VTAM is a 4-character string in the form
of either VT<i>vr</i> or Vv<i>rm</i>, where:<br/>
<b>VT</b> Indicates that the access method is the VTAM program.<br/>
<i>v</i> Indicates the version number<br/>
<i>r</i> Indicates the release number<br/>
<i>m</i> Indicates the modification number<br/>
			<b>Note:</b> The value of the VTAM is null if the VTAM program is not
active.<br/>
<b>VTCOMPID</b><br/>
Is a 14-character VTAM component identifier. The VTAM component
identification can be:<br/>
5695-11701-<i>xxx</i><br/> <b>Where: </b><i>xxx</i><br/> is the release number.<br/> Additional VTAM component identifiers can be added in future
updates to VTAM.<br/>
<b>Note: </b>The value of VTCOMPID is null if VTAM is not active.<br/>
<b>YEAR</b> Is the 4-digit year.<br/> <b>Usage Notes:</b><br/>
1. Refer to <i>IBM Tivoli NetView for z/OS Programming: REXX and the NetView
Command List Language</i> for a complete description of the NetView command list
language variables.<br/>
2. CLOCK, PID, and STARTIME are 8-character representations of the TOD-clock
(time-of-day) value returned by the STCK instruction.<br/>
<b>Return Codes:</b><br/>
			
		</p>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_DATA_TRUNC</td>
				<td>0</td>
				<td>The value requested is returned in <i>icdata</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>40</td>
				<td><i>icdatlen</i> was too small. Data truncated.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>52</td>
				<td>Incorrect icname. Value unchanged.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>icdatlen</i> less than  0.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by icdata is not addressable.</td>
			</tr>
		</table>
		<h3><b>CNMINFI (CNMINFOI): Query NetView Integer Information</b></h3>
		<p>
			Use the CNMINFI routine to obtain information about the current NetView
environment. CNMINFI returns integer data.<br/>
The CNMINFI routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMINFI(<i>hlbptr,iiname,iinumb</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMINFOI ITEM(<i>iiname</i>) DATA(<i>iinumb</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnminfi(char *<i>iiname</i>, int *<i>iinumb</i>)
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
			<i>iiname</i><br/>
Is an 8-byte character field that specifies the name of the variable. Valid names
are:<br/>
<b>ABENDRTN<sup>1</sup></b><br/> If processing as a long-running command ABEND routine, then return
true.<br/>
<b>ASID</b><br/> Is the NetView's current address space identifier. The value of ASID is
a 1-to 5-digit decimal number.<br/> <b>ATTENDED<sup>1</sup></b><br/> Is a single character variable with a value of 1 or 0.<br/>
The values for ATTENDED are:<br/>
			<b>1</b> Indicates one of the following tasks:<br/>
		</p>
		<ul>
			<li>An OST with a display</li>
			<li>An NNT with a corresponding OST</li>
			<li>An autotask with an associated MVS console assigned using
the AUTOTASK command</li>
			<li>A distributed autotask</li>
		</ul>
		<p><b>0</b>Indicates one of the following tasks:</p>
		<ul>
			<li>An autotask without an associated MVS console assigned
using the AUTOTASK command</li>
			<li>Another type of task, such as a DST or an OPT task</li>
		</ul>
		<p>
			<b>Note:</b>
1. If the associated operator is an autotask, the presentation data is
not eligible for display unless the autotask is associated with an
active MVS console.<br/>
2. ATTENDED can be used in conjunction with DISTAUTO and
AUTOTASK variables to further define the characteristics of the
task. For example, if ATTENDED is 1, DISTAUTO is 0, and
AUTOTASK is 1, then the task is an autotask with an associated
MVS console.<br/>
<b>AUTOTASK</b><br/>
The single character value of either 1 or 0 indicating whether or not a
task is an autotask. The values follow:<br/>
<b>1</b> Indicates that the task is an autotask<br/>
<b>0</b> Indicates that the task is not an asterisk<br/>
These <i>iinames</i> contain Boolean values (0 = false and 1 = true).<br/>
<b>AWAITINP<sup>1</sup></b> If waiting for operator input, then return true.<br/>
<b>CLOSING<sup>1</sup></b> If NetView is terminating, then return true.<br/>
<b>COLORS</b><br/>
Is the number of colors that can be displayed.<br/>
			<b>DISTAUTO</b><br/>
Denotes if task is a distributed autotask started with the RMTCMD
command. The values are as follows:<br/>
<b>1</b> Indicates the task is a distributed autotask<br/>
<b>0</b> Indicates the task is not a distributed autotask<br/>
<b>LOGOFRTN<sup>1</sup></b> If processing as a long-running command routine, then return true.<br/>
<b>MVTUFLD</b><br/>
Is the user field from the DSIMVT NetView control block (MVTUFLD).<br/>
<b>OPER3270<sup>1</sup></b><br/> If an OST with a 327x display terminal is attached, then return true.<br/>
<b>RESETREQ<sup>1</sup></b><br/> If RESET or CANCEL was requested, then return true. the internal
RESET flag is turned off as a result of this query. See “RESET
command” on page 179 for further details.<br/>
<b>SCRNSER</b><br/>
Is the return serial number of the screen update.<br/>
<b>TIBUFLD</b><br/>
Is the user field from the DSITIB NetView control block (TIBUFLD).<br/>
<b>TVBUFLD</b><br/>
Is the user field from the DSITVB NetView control block (TVBUFLD).<br/>
<b>USEREXIT</b><br/>
If the integer value is 0, the environment is that of a command
processor.>br/> If the integer value is 2–17, the environment is that of an installation
exit.<br/>
If the integer value is one of the following values, the environment is
that of an installation exit running under a DST:<br/>
<b>233 USERDINT</b><br/>
DSM initialization exit<br/>
<b>234 USERVINT</b><br/>
VSAM initialization exit<br/>
<b>235 USERVINP</b><br/>
VSAM input exit<br/>
<b>236 USERVOUT</b><br/>
VSAM output exit<br/>
<b>237 USERCINP</b><br/>
CNMI input exit<br/>
<b>238 USERCOUT</b><br/>
CNMI output exit<br/>
<b>240 USERXLOG</b><br/>
External log exit<br/>
<b>241 USERBINT</b><br/>
Sequential log initialization exit<br/>
<b>242 USERBOUT</b><br/>
Sequential log output exit<br/>
			See DSIPCONS in Appendix A, “PL/I Control Blocks and Include
Files,” on page 269 or DSICCONS in Appendix C, “C language control
blocks and include files,” on page 279 for a list of constants useful
when coding installation exit routines.<br/>
<b>WEEKDAYN</b><br/>
Is a numeric value from 1 to 7 indicating the day of the week (from
Monday through Sunday). These are the values that are returned:<br/>
1 = Monday<br/>
2 = Tuesday<br/>
3 = Wednesday<br/>
4 = Thursday<br/>
5 = Friday<br/>
6 = Saturday<br/>
7 = Sunday<br/>
<i>iinumb</i><br/>
Is a 4-byte integer field containing the integer value returned.
<b>Return Codes:</b><br/>
			
		</p>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>The value requested is returned in iinumb.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect iiname. Value unchanged.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by iinumb is not addressable.</td>
			</tr>
		</table>
		<h3><b>CNMIPXL (CNMIPXLATE): IP Address Translation</b></h3>
		   <p>
			   The CNMIPXL service routine can be used by writers of HLL command
procedures to validate a presentation form IP address and convert it to another
format, either a standard format or a compressed format. It can also convert an IP
address in binary to a presentation form of the IP address.<br/>
The CNMIPXL routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMIPXL(<i>hlbptr,xltype,xlinData,xlinLen,xloutData,xloutLen</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMIPXLATE TYPE(<i>xltype</i>) INDATA(<i>xlinData</i>) INLEN(<i>xlinData</i>)
OUTDATA(<i>xloutData</i>) OUTLEN(<i>xloutLen</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmipxl(char *<i>xltype</i>,<br/>
void *<i>xlinData</i>,<br/>
int <i>xlinLen</i>,<br/>
void *<i>xloutData</i>,<br/>
int <i>xloutLen</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
A 4-byte pointer containing the address of the HLB control block.<br/>
<i>xltype</i><br/>
An 8-byte string containing the type of IP address verification or translation to
be done. The valid strings follow:<br/>
<i>PCHECK</i><br/>
Verify that the input data is an IP address in presentation form.<br/>
<b>P2PV4</b> Convert an IP address in presentation form to standard presentation
form, in which IPv4, IPv4-mapped IPv6, and IPv4-compatible IPv6
addresses are presented in dotted decimal IPv4 address format. The
IPv6 addresses are presented in colon hex format. In a standard
presentation form, all segments of an address are present and leading
zeros are removed.<br/>
<b>P2PV6</b> Convert an IP address in presentation form to an IPv6 presentation
form. The IPv4 and IPv4-mapped IPv6 addresses are presented as
IPv4-mapped IPv6 addresses. All IP addresses are returned in standard
presentation form.<br/>
<b>P2PCOMP</b><br/>
Convert an IP address in presentation form to presentation form
compressed, in which one group of multiple, consecutive zero address
segments is replaced by a double-colon (::). The compression only
applies to IPv4-mapped IPv6, IPv4-compatible IPv6, and IPv6
addresses. The IPv4 addresses are returned in standard presentation
form.<br/>
<b>P2NV4</b><br/>
Convert an IP address in presentation form to a 4-byte binary (network
byte order) representation of an IPv4 address. Only IPv4, IPv4-mapped
IPv6, and IPv4-compatible IPv6 addresses can be converted.<br/>
<b>P2NV6</b><br/>
Convert an IP address in presentation form to a 16-byte binary
(network byte order) representation of an IP address. An IPv4 address
is converted to the binary representation of an IPv4-mapped IPv6
address.<br/>
<b>N2PSTD</b><br/>
Convert an IP address in binary (network byte order) to a standard
presentation form. The IPv4, IPv4-mapped IPv6, and IPv4-compatible
IPv6 addresses are converted to the dotted decimal IPv4 address
format.<br/>
<b>N2PSTDM4</b><br/>
Convert an IP address in binary to a standard presentation form. The
IPv4-mapped IPv6, IPv4-compatible IPv6, and IPv6 addresses are
returned in their standard presentation forms. An IPv4 address is
returned in IPv4-mapped IPv6 presentation form.<br/>
<b>N2PSTDC4</b><br/>
Convert an IP address in binary to a standard presentation form. This
is similar to the N2PSTDM4 option, except that an IPv4 address is
returned in an IPv4-compatible IPv6 presentation form.<br/>
<b>N2PV4</b><br/>
Convert an IP address in binary to the dotted decimal standard
			   presentation form for an IPv4 address. Only IPv4, IPv4-mapped IPv6,
and IPv4-compatible IPv6 addresses can be converted in this format.<br/>
<b>N2PCOMP</b><br/>
Convert an IP address in binary to its presentation form compressed.
An IPv4 address is returned in dotted decimal standard presentation
form, while all other address types are compressed, if possible.<br/>
<i>xlinData</i><br/>
A 4-byte pointer field containing the address of the IP address data to be
verified or translated.<br/>
<i>xlinLen</i><br/>
A 4-byte integer containing the length of the input IP address data.<br/>
<i>xloutData</i><br/>
A 4-byte pointer field containing the address of an area into which a converted
IP address is to be placed. This parameter is ignored if PCHECK is requested.
The caller is expected to provide sufficient storage for the data that can be
returned.<br/>
<i>xloutLen</i><br/>
A 4-byte integer containing the length of the area into which the converted IP
address data is to be placed. This parameter is ignored if PCHECK is
requested.<br/>
<b>Usage Notes:</b><br/>

		</p>
		<ol>
			<li>Upon return to the caller, Hlbrc (C) or HLBRC (PL/I) contains the return code
from the IP address verification/translation service. When the call is for an IP
address translation request and the return code is CNM_GOOD, Hlbleng (C) or
HLBLENG (PL/I) contains the length of the translated IP address data placed
in the output data area.</li>
			<li>When using CNMIPXL with C, xlinData and <i>xloutData</i> (if the requested type is
not PCHECK) must be passed as addresses of pointers to the respective IP
address data areas. As an example, assume that inData has been defined as an
area that holds IP address data to be converted and outData has been defined
as the area to contain the translated IP address. The following lines illustrate
how this information would then be passed to the CNMIPXL service:<br/>
				/* Define the pointers to the IP address data areas. */<br/>
void *pInIPAddress;<br/>
void *pOutIPAddress;<br/>
/* Sets the input and output data pointers for the Cnmipxl call. */<br/>
pInIPAddress = (void *)&inData;<br/>
xlinData = (void *)&pInIPAddress;<br/>
pOutIPAddress = (void *)&outData;<br/>
xloutData = (void *)&pOutIPAddress;<br/>
			</li>
			<li>If an IP address translation request succeeded but the translated IP address
data did not fit in the area whose length is contained in xloutLen, then the
following things happen:
				<ul>
					<li>The xloutLen bytes of translated IP address data are placed in the output data
area</li>
					<li>Hlbrc (C) or HLBRC (PL/I) is set to CNM_DATA_TRUNC</li>
					<li>Hlbleng (C) or HLBLENG (PL/I) is set to the size of the storage area that
would be necessary to hold the translated IP address data</li>
				</ul>
			</li>
		</ol>
		
		<b>Return Codes:</b>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>IP address verified or translated.</td>
			</tr>
			<tr>
				<td>CNM_DATA_TRUNC</td>
				<td>40</td>
				<td>IP address translated but did not fit into
output data area.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect <i>xltype</i> value.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td>Incorrect <i>xlinLen</i> or <i>xloutLen</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>Effectively zero <i>xlinData</i> or <i>xloutData</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_P_IPXLATE + x</td>
				<td>26000 + x</td>
				<td>Failed IP address verification or translation.
The x is the return code from a service
routine that handles presentation form
verification and translation.</td>
			</tr>
			<tr>
				<td>CNM_BAD_N_IPXLATE +
x</td>
				<td>27000 + x</td>
				<td>Failed IP address translation. The x is the
return code from a service routine that
handles network byte order (binary)
translation.</td>
			</tr>
		</table>
		<h3><b>CNMKIO (CNMKEYIO): Keyed File Access Under a DST</b></h3>
		<p>
			The CNMKIO service routine provides access to DST managed key-sequenced
VSAM files from an HLL command processor. This service routine performs its
function only when started from an HLL command processor running under a
DST. Calls from other environments are rejected.<br/>
The CNMKIO routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMKIO(<i>hlbptr,vsfunc,vsdata,vsdatlen,vskey,vsoption</i>)
<b>PL/I MACRO FORMAT:</b><br/>
CNMKEYIO FUNC(<i>vsfunc</i>) DATA(<i>vsdata</i>) LENG(<i>vsdatlen</i>)
KEY(<i>vskey</i>) OPTIONS(<i>vsoption</i>)
<b>C INVOCATION:</b><br/>
void Cnmkio(char *<i>vsfunc</i>, void *<i>vsdata</i>, int <i>vsdatlen</i>, void *<i>vskey</i>,
char *<i>vsoption</i>)
<b><i>Where:</i></b>
<i>hlbptr</i>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>vsdata</i><br/>
Is a varying length character field containing the buffer to be returned or
written. You provide this field for PUT. This field is returned for GET and is
not required for ERASE or ENDREQ.<br/>
<i>vsdatlen</i><br/>
Is a 4-byte integer field containing the length of vsdata. This is the maximum
length of the area provided to receive the returned data. You provide the value
of vsdatlen. This field is required only for GET.<br/>
			If the value specified by vsdatlen is less than the length of the data to be
returned, the truncated data is returned in vsdata and a return code of
			CNM_DATA_TRUNC is generated. The full length of the data that was
truncated is stored in HLBLENG (<i>Hlbleng</i>).<br/>
If the value specified by <i>vsdatlen</i> is equal to or greater than the length of the
data to be returned, and HLBRC (<i>Hlbrc</i>) = CNM_GOOD, the length of the
returned data is stored in HLBLENG (<i>Hlbleng</i>).<br/>
If the value specified by vsdatlen is greater than the length of the receiving data
buffer (<i>vsdata</i>), a storage overlay can occur. Take special care when deciding
the value of <i>vsdatlen</i>.<br/> <i>vsfunc</i><br/>
Is an 8-byte character field that specifies the function to performed.<br/>
<b>ENDREQ</b><br/>
Cancels a request for update.<br/>
<b>ERASE</b><br/>
Erases the record.<br/>
<b>GET_EH</b><br/>
Gets a record equal to or higher than the key.<br/>
			<b>GET_EQ</b><br/>
Gets a record equal to the key.<br/> <b>Note:</b> The key field must match exactly, including blanks.<br/>
<b>GET_NEXT</b><br/>
Gets the next record in ascending sequence.<br/>
<b>GET_PREV</b><br/>
Gets the next record in descending sequence.<br/>
<b>PUT</b> Writes or rewrites the record.<br/>
<i>vskey</i><br/>
A varying length character field containing the VSAM key used for access to
the requested data. This field is required for GET_EQ, GET_EH, or
ERASE/DIRECT.<br/>
			<b>vsoption</b><br/>
Is an 8-byte character field that specifies the type of access to the file. You
provide this field for all functions except ENDREQ.<br/>
<b>DIRECT</b><br/>
Put a new record directly to the file or erase a record directly from the
file (without invoking GET first). You can use PUT/DIRECT only for a
new record. If the record already exists, CNM_DUPL_KEY is returned.
For an existing record, ERASE/DIRECT gives the same result as
GET/UPDATE followed by ERASE/UPDATE. If the record does not
exist, CNM_NOT_FOUND is returned. You can use DIRECT only with
PUT and ERASE.<br/>
<b>NOUPDATE</b><br/>
The record is not updated. You can use NOUPDATE only with GET. UPDATE
Get a record for update or replace. Erase the record that was gotten for
update. PUT/UPDATE and ERASE/UPDATE must be preceded by a
successful GET/UPDATE. You can use UPDATE only with GET, PUT, and ERASE<br/>
			<b>Usage Notes:</b><br/>
			
		</p>
		<ol>
				<li>You cannot issue CNMKIO from an HLL installation exit routine or from an
HLL command processor while holding a lock.</li>
				<li>For more information about installing a DST, see Chapter 3, “HLL Data Services
command processors,” on page 27.</li>
		</ol>
		<b>Return Codes:</b>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_BAD_INVOCATION</td>
				<td>4</td>
				<td>Not started from a command processor</td>
			</tr>
			<tr>
				<td>CNM_NOT_FOUND</td>
				<td>20</td>
				<td>Record with requested <i>vskey</i> not found.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Nonzero return code from DSIGET macro.</td>
			</tr>
			<tr>
				<td>CNM_END_FILE</td>
				<td>36</td>
				<td>End of file encountered.</td>
			</tr>
			<tr>
				<td>CNM_DATA_TRUNC</td>
				<td>40</td>
				<td><i>vsdatlen</i> was too small. Data truncated.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect <i>vsfunc</i></td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>vsdatlen</i> less than 0.</td>
			</tr>
			<tr>
				<td>CNM_BAD_OPTION</td>
				<td>128</td>
				<td>Incorrect <i>vsoption</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by <i>vsdata</i> is not
addressable.</td>
			</tr>
			<tr>
				<td>CNM_BAD_COMBO</td>
				<td>176</td>
				<td>Incorrect combination <i>vsfunc</i> and <i>vsoption</i>.</td>
			</tr>
			<tr>
				<td>CNM_DUPL_KEY</td>
				<td>200</td>
				<td>Record with requested key already exists.
Existing record is not changed.</td>
			</tr>
			<tr>
				<td>CNM_LOCKED</td>
				<td>208</td>
				<td>CNMKIO issued while holding a lock.</td>
			</tr>
			<tr>
				<td>(CNM_BAD_ZVSMS + X) *
256 + Y</td>
				<td>(100 + X) * 256
+ Y</td>
				<td>Nonzero return code from DSIZVSMS. X is
the major return code from DSIZVSMS. Y is
the minor return code from DSIZVSMS.</td>
			</tr>
			<tr>
				<td>CNM_DST_FAILURE + X</td>
				<td>2000 + X</td>
				<td>Nonzero return code, X, which is the DSRB
minor return code for solicited CNMI data
or VSAM data set services.</td>
			</tr>
			
		</table>
		<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler </i>or the VSAM library
for more information.</p>
		<h3><b>CNMLK (CNMLOCK): Controlling a Lock</b></h3>
		<p>
			You can use the CNMLK service routine to obtain, release, and test the control of a
named lock. You can use this service to serialize access to resources shared by
multiple tasks. CNMLK does not allow for serialization within a task. HLL
command processors holding a lock cannot use any services that can suspend
execution of an HLL command processor.<br/> The CNMLK routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMLK(<i>hlbptr,lkfunc,lkname,lkscope,lkoption</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMLOCK FUNC(<i>lkfunc</i>) NAME(<i>lkfunc</i>) SCOPE(<i>lkscope</i>) OPTION(<i>lkoption</i>)
			<b>C INVOCATION:</b><br/>
void Cnmlk(char *<i>lkfunc</i>, void *<i>lkname</i>, char *<i>lkscope</i>, char *<i>lkoption</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>lkfunc</i><br/>
Is an 8-byte character field that specifies the function to be performed:<br/>
<b>LOCK</b> Obtains control of the lock name.<br/>
<b>TEST</b> Tests if the lock name is available.<br/>
<b>UNLOCK</b><br/>
Releases control of the lock name.<br/>
<i>lkname</i><br/>
Is a varying length character field to hold the user-defined name of the lock.
(Length is 1–12 characters.) This field is required for all functions.<br/>
<i>lkoption</i><br/>
Is an 8-byte character field that specifies whether the HLL command processor
or installation exit routine waits for the lock to become available. This field is
required only for LOCK. Possible values follow:<br/>
<b>NOWAIT</b><br/>
Do not wait if the lock is not available. An appropriate return code is
returned (CNM_LOCKED or CNM_LOCK_INUSE).<br/>
<b>WAIT</b> Wait until the lock is available. The task is suspended.<br/>
<i>lkscope</i><br/>
Is an 8-byte character field reserved for future use. Provide a null or blank
value in this field for all functions.<br/>
<b>Usage Notes:</b><br/>
		</p>
		<ol>
				<li>Do not invoke CNMSMSG with smdestyp = OPER while holding a lock. The
operator task can be running with autowrap off, and the HLL command
processor or installation exit routine might hang waiting for the operator to
clear the screen, thus holding the lock for an indefinite period.</li>
				<li> A hierarchical order on lock requests is used to prevent deadlock. The
alphabetical order of the lock names defines the hierarchy. Therefore, lock
requests for lock names alphabetically less than or equal to a presently held
lock name fail, and return code CNM_LOCKED is generated. For example,
assume the last lock request was for lkname = GVARIABLE. A new lock request
for lkname = TVARIABLE is successful because TVARIABLE is alphabetically
greater than GVARIABLE. However, a new lock request for lkname = CVARIABLE is unsuccessful because CVARIABLE is alphabetically less than or
equal to GVARIABLE. Return code CNM_LOCKED is generated and the lock
request fails.</li>
		</ol>
		<b>Return Codes:</b><br/>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Nonzero return code from DSIGET macro.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect <i>lkfunc</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_NAME</td>
				<td>108</td>
				<td>Length of <i>lkname</i> greater than (>) 12
characters or the specified lkname was not
locked.</td>
			</tr>
			<tr>
				<td>CNM_BAD_OPTION</td>
				<td>128</td>
				<td>Incorrect <i>lkoption</i>.</td>
			</tr>
			<tr>
				<td>CNM_LOCKED</td>
				<td>208</td>
				<td>The <i>lkname</i> is unavailable because it is
alphabetically less than or equal to the lock
name of the last lock request.</td>
			</tr>
			<tr>
				<td>CNM_LOCK_INUSE</td>
				<td>212</td>
				<td><i>lkname</i> is not available; currently held by
another task.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ENQ + X</td>
				<td>21000 + X</td>
				<td>Nonzero return code X from DSIENQ macro.</td>
			</tr>
			
			
		</table>
		<p>Refer to<i> IBM Tivoli NetView for z/OS Programming: Assembler</i> or the MVS/XA library
for more information.</p>
		<h3><b>CNMMEMC (CNMCLOSMEM): Close NetView Partitioned Data
Set</b></h3><br/>
		<p>
			Use the CNMMEMC service routine to close a member of a NetView partitioned
data set that was previously opened by CNMMEMO. The token returned by
CNMMEMO must be passed to CNMMEMC to allow the file to be closed. All
members opened by CNMMEMO are automatically closed at program termination.<br/>
The CNMMEMC routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMMEMC(<i>hlbptr,mctoken</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMCLOSMEM TOKEN(<i>mctoken</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmmemc(int <i>mctoken</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>mctoken</i><br/>
Is a 4-byte integer field containing the token returned by CNMMEMO.<br/>
<b>Return Codes:</b><br/>
		</p>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_BAD_TOKEN</td>
				<td>32</td>
				<td>Token not found.</td>
			</tr>
			<tr>
				<td>CNM_BAD_DKS + X</td>
				<td>10000 + X</td>
				<td>Nonzero return code, X, from DSIDKS macro.</td>
			</tr>
		</table>
		<p>Refer to<i> IBM Tivoli NetView for z/OS Programming: Assembler</i> for more information.</p><br/>
		<h3><b>CNMMEMO (CNMOPENMEM): Open NetView Partitioned Data
Set</b></h3>
		<p>
			Use the CNMMEMO service routine to open members of NetView partitioned data
sets. A token identifying the open member is returned to you. This token is passed
to CNMMEMR to read records from the member and to CNMMEMC to close the
member.<br/> The CNMMEMO routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMMEMO(<i>hlbptr,motoken,moddname,momemnam</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMOPENMEM TOKEN(<i>motoken</i>) DATASET(<i>moddname</i>) MEMBER(<i>momemnam</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmmemo(int *<i>motoken</i>, char *<i>moddname</i>, char *<i>momemnam</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>moddname</i><br/>
Is an 8-byte character field that specifies the DD name of the partitioned data
set. The NetView predefined DD names are:<br/>
		</p>
		<ul style="list-style-type: none;">
			<li>BNJPNL1</li>
			<li>BNJPNL2</li>
			<li>CNMPNL1</li>
			<li>DSICLD</li>
			<li>DSILIST</li>
			<li>DSIMSG</li>
			<li>DSIOPEN</li>
			<li>DSIPARM</li>
			<li>DSIPRF</li>
			<li>DSIVTAM</li>
			
		</ul>
		<p>
			<i>momemnam</i><br/>
Is an 8-byte character field that specifies the name of the member.<br/> <i>motoken</i><br/>
Is a 4-byte integer field containing the token to be used by subsequent
CNMMEMR and CNMMEMC requests.<br/>
<b>Return Codes:</b><br/>
		</p>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_BAD_DDNAME</td>
				<td>16</td>
				<td> Incorrect <i>moddname</i> (not found).</td>
			</tr>
			<tr>
				<td>CNM_NOT_FOUND</td>
				<td>20</td>
				<td><i>momemnam</i> not found.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Nonzero return code from DSIGET macro.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by motoken is not
addressable.</td>
			</tr>
						<tr>
				<td>CNM_BAD_DKS + X</td>
				<td>10000 + X</td>
				<td>Nonzero return code, X, from DSIDKS macro.</td>
			</tr>
		</table>
		<p>Refer to<i> IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.</p>
		<h3><b>CNMMEMR (CNMREADMEM): Read NetView Partitioned Data
Set</b></h3>
		<p>
			Use the CNMMEMR service routine to read a record from a member of a NetView
partitioned data set that was previously opened by CNMMEMO. The token
returned by CNMMEMO must be passed to CNMMEMR to allow reading.<br/>
The CNMMEMR routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMMEMR(<i>hlbptr,mrtoken,mrdata,mrdatlen,mrinclude</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMREADMEM TOKEN(<i>mrtoken</i>) DATA(<i>mrdata</i>) LENG(<i>mrdatlen</i>) INCL(<i>mrinclude</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmmemr(int <i>mrtoken</i>, void *<i>mrdata</i>, int <i>mrdatlen</i>, char *<i>mrinclude</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>mrdata</i><br/>
Is a varying length character field to contain the received record.<br/>
<i>mrdatlen</i><br/>
Is a 4-byte integer field containing the length of <i>mrdata</i>. This is the maximum
length of the area provided to receive the returned record. You provide the
value of <i>mrdatlen</i>. If the value specified by mrdatlen is less than the length of the record to be
returned, the truncated record is returned in mrdata and a return code of
CNM_DATA_TRUNC is generated. The full length of the truncated record is
stored in HLBLENG (<i>Hlbleng</i>).<br/>
If the value specified by mrdatlen is equal to or greater than the length of the
record to be returned, and HLBRC (<i>hlbrc</i>) = CNM_GOOD, the length of the
returned record is stored in HLBLENG (<i>Hlbleng</i>).<br/>
If the value specified by mrdatlen is greater than the length of the receiving
data buffer (<i>mrdata</i>), a storage overlay can occur.<br/> <i>mrinclude</i><br/>
Is a 6-byte character field that specifies whether INCLUDE cards are to be
processed:<br/>
<b>INCL</b> Specifies to process INCLUDE cards.<br/>
<b>NOINCL</b><br/>
Specifies that INCLUDE cards are not processed.<br/>
			<i>mrtoken</i><br/>
Is a 4-byte integer field containing the token returned by CNMMEMO.<br/>
<b>Usage Note:</b> If the return code indicates that there was a problem with an
INCLUDE card or the member specified by the include card
(CNM_SYNTAX_ERROR, CNM_INVAL_MEMBER, CNM_INVAL_NEST, CNM_SYSTEM_ERROR), the record returned in mrdata is the INCLUDE card that
is not valid.<br/>
<b>Return Codes:</b><br/>
		</p>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_IOERROR</td>
				<td>28</td>
				<td>I/O error occurred.</td>
			</tr>
			<tr>
				<td>CNM_BAD_TOKEN</td>
				<td>32</td>
				<td>Token not found.</td>
			</tr>
			<tr>
				<td>CNM_END_FILE</td>
				<td>36</td>
				<td>End of file encountered.</td>
			</tr>
			<tr>
				<td>CNM_DATA_TRUNC</td>
				<td>40</td>
				<td><i>mrdatlen</i> was too small. Data truncated.</td>
			</tr>
						<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>mrdatlen</i> less than 0.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by mrdata is not
addressable.</td>
			</tr>
			<tr>
				<td>CNM_SYNTAX_ERROR</td>
				<td>520</td>
				<td>Syntax error in INCLUDE card.</td>
			</tr>
			<tr>
				<td>CNM_INVAL_MEMBER</td>
				<td>524</td>
				<td>Incorrect member specified in INCLUDE card.</td>
			</tr>
			<tr>
				<td>CNM_INVAL_NEST</td>
				<td>528</td>
				<td>Incorrect nesting of INCLUDE cards.</td>
			</tr>
			<tr>
				<td>CNM_SYSTEM_ERROR</td>
				<td>532</td>
				<td>Internal NetView system error while
processing INCLUDE card.</td>
			</tr>
			<tr>
				<td>CNM_BAD_INCLUDE</td>
				<td>536</td>
				<td>Incorrect value for mrinclude.</td>
			</tr>
						<tr>
				<td>CNM_BAD_DKS + X</td>
				<td>10000 + X</td>
				<td>Nonzero return code, X, from DSIDKS macro.</td>
			</tr>
		</table>
		<p>Refer to<i> IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.</p>
		<h3><b>CNMNAMS (CNMNAMESTR): Named Storage</b></h3>
		<p>
			The CNMNAMS routine allows you to allocate, free, locate, and reallocate named
areas of virtual storage.<br/>
The CNMNAMS routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMNAMS(<i>hlbptr,nsfunc,nsptr,nsname,nsleng,nsclass</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMNAMESTR FUNC(<i></i>) STRPTR(<i>nsptr</i>) NAME(<i>nsname</i>)<br/>
LENG(<i>nsleng</i>) CLASS(<i>nsclass</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmnams(char *<i>nsfunc</i>, void *<i>nsptr</i>, void *<i>nsname</i>, int *<i>nsleng</i>,
int <i>nsclass</i>)<br/>
<i><b>Where:</b></i><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
			<i>nsclass</i><br/>
Is a 4-byte integer field containing the class of the named storage area, as
follows:<br/>
0 = Residency of caller<br/>
1 = 31-bit storage<br/>
2 = 24-bit storage<br/>
This field is required by the caller for ALLOC and REALLOC. This field is not
required for FREE or LOCATE.<br/>
<i>nsfunc</i><br/>
Is an 8-byte character field that specifies the function to be performed:<br/>
<i>ALLOC</i><br/>
Allocates the named storage area.>br/>
FREE Frees or deallocates the named storage area.<br/>
<b>LOCATE</b><br/>
Locates the existing named storage area.<br/>
<b>REALLOC</b><br/>
Reallocates the named storage area. Old data is preserved.<br/>
<i>nsleng</i><br/>
Is a 4-byte integer field containing the size of the named storage area. This
field is required by the caller for ALLOC and REALLOC and is returned to the
caller for LOCATE. This field is not required for FREE.<br/>
<i>nsname</i><br/>
Is a varying length character field containing the name of the storage area. This
field is required for all functions and is provided by the caller. nsptr
Is a 4-byte pointer field containing the address of the named storage. This field
is required by the caller for ALLOC, REALLOC, and LOCATE. This field is not
required for FREE.<br/>
			<b>Usage Notes:</b><br/>
		</p>
		<ol>
			<li>The named storage areas provide a way of sharing data among different HLL
command processors and installation exit routines or among multiple
invocations of an HLL command processor or installation exit routine. When
allocated, a named storage area remains allocated until it is either explicitly
freed or the task under which it was allocated ends.</li>
			<li>A named storage area is associated with the NetView subtask under which it
was allocated. Named storage areas can be manipulated (using LOCATE, FREE,
or REALLOCATE) only by HLL command processors and installation exit
routines running under the mainline of that task. You cannot reference a named
storage area from a task other than the one with which it is associated.</li>
			<li>If ALLOC is requested for a name that has already been allocated, the address
of the existing area is returned along with a nonzero return code.</li>
			<li>of the existing area is returned along with a nonzero return code.
4. If a previously allocated named storage area is reallocated to be larger than the
original area, the content of the original area is preserved. If a previously
allocated named storage area is reallocated to be smaller than the original area,
the content of the original area is truncated at the length specified by the nsleng
operand.</li>
		</ol>
		<b>Return Codes:</b><br/>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_NOT_FOUND</td>
				<td>20</td>
				<td>REALLOC, FREE, or LOCATE requested but no
previous ALLOC was done.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Nonzero return code from DSIGET macro.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect function.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>nsleng</i> less than 0.</td>
			</tr>
						<tr>
				<td>CNM_DUPL_NAME</td>
				<td>104</td>
				<td><i>nsname</i> already allocated. Allocation not done.</td>
			</tr>
			<tr>
				<td>CNM_BAD_NAME</td>
				<td>108</td>
				<td>Length of nsname greater than (>) 12 characters.</td>
			</tr>
			<tr>
				<td>CNM_BAD_CLASS</td>
				<td>112</td>
				<td>Incorrect <i>nsclass</i></td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by nsname or nsleng is
not addressable.</td>
			</tr>
			<tr>
				<td>CNM_BAD_PUSH + X</td>
				<td>4000 + X</td>
				<td>Nonzero return code, X, from DSIPUSH macro..</td>
			</tr>
			<tr>
				<td>CNM_BAD_POP+X</td>
				<td>5000 + X</td>
				<td>Nonzero return code, X, from DSIPOP macro.</td>
			</tr>
			
		</table>
		<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler</i> for more information.</p>
		<h3><b>CNMPMDB (CNMPRSMDB): Process Message Data Block</b></h3>
		<p>
			The CNMPMDB service routine requests the NetView message processor to
process a message data block (MDB) and its companion source object.<br/>
CNMPMDB accepts an MDB and a source object, transforms them into an
automation internal function request (AIFR), and sends the AIFR through normal
NetView message processing including invoking the automation table. The
transformation of the MDB and source object into an AIFR includes establishing
the values for the AIFR variables, such as MSGSRCNM and MSGSRCOB.<br/>
The CNMPMDB routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMPMDB(<i>hlbptr,mdmdb,mdsource,mdcorr</i>)<br/>
<b>PL/I MACRO FORMAT:</b><br/>
CNMPRSMDB MDB(<i>mdmdb</i>) SOURCE(<i>mdsource</i>) CORREL(<i>mdcorr</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmpmdb(void *<i>mdmdb</i>, void *<i>mdsource</i>, void *<i>mdcorr</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>mdcorr</i><br/>
Is a 16-character correlator value used for chaining together multiple related
MDBs.<br/>
Pass this parameter as all binary zeros for CNMPMDB invocations for single
(non-chained) MDBs.<br/>
			For multiple related MDBs, pass all binary zeros for the mdcorr parameter on
the first CNMPMDB invocation.<br/>
CNMPMDB returns a correlator value in <i>mdcorr</i>. On subsequent calls to
CNMPMDB for the multiple MDBs, pass the correlator value which was
returned in mdcorr on the first invocation of CNMPMDB.<br/>
When an MDB is sent with an end of text indicator, the mdcorr is returned with
a zero value.<br/>
<i>mdmdb</i><br/>
Is a 4-byte pointer field containing the address of an MDB. The maximum
length of an MDB is 4 KB bytes. The maximum length of multiple related
MDBs is 63 KB.<br/>
<i>mdsource</i><br/>
Is a 4-byte pointer field containing the address of the source object. This is an
optional field. If you do not want to specify a source object, pass zero in
<i>mdsource</i>.<br/>
			<b>Usage Notes:</b><br/>
		</p>
		<ol>
			<li>The CNMPMDB service routine returns control to the invoking program after it
has scanned the automation table and done the synchronous portion of
message processing.</li>
			<li>The service does not free the MDB or source object.</li>
			<li>If you create DOM MDBs, keep in mind that not all forms of DOM can be
transported over OST-NNT sessions. If you are using any OST-NNT sessions,
only create DOM MDBs that indicate DOM by MSGID.</li>
		</ol>
		<b>Return Codes:</b><br/>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>The MDB is accepted for processing.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Storage is not available.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by mdcorr is not
addressable.</td>
			</tr>
			<tr>
				<td>CNM_BAD_SEQUENCE</td>
				<td>564</td>
				<td> Third operand is not a valid correlator
value.</td>
			</tr>
			<tr>
				<td>CNM_BAD_MDB</td>
				<td>568</td>
				<td>First operand is not valid for message data
block (MDB).</td>
			</tr>
						<tr>
				<td>CNM_BAD_SOURCE_OBJ</td>
				<td>572</td>
				<td>Second operand is not a valid source object.</td>
			</tr>
		</table>
		<h3><b>CNMPOOL (CNMSTRPOOL): Storage Pool</b></h3>
		<p>
			You can use the CNMPOOL service routine to allocate, free, and locate storage
pools. A storage pool is composed of one primary and zero or more secondary
blocks of storage. Each storage block has a specified number of cells (of equal size)
that can be allocated or freed using CNMCELL. Storage pool services provide a
way to effectively manage large numbers of fixed size storage elements.<br/>
The CNMPOOL routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMPOOL(<i>hlbptr,spfunc,sptoken,spname,spleng,sppricnt, spseccnt,spclass</i>)<br/>
			<b>PL/I MACRO FORMAT:</b><br/>
CNMSTRPOOL FUNC(<i>spfunc</i>) TOKEN(<i>sptoken</i>) NAME(<i>spname</i>)<br/>
LENG(<i>spleng</i>) PRICELLS (<i>sppricnt</i>) SECCELLS(<i>spseccnt</i>) CLASS(<i>spclass</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmpool(char *<i>spfunc</i>, int *<i>sptoken</i>, void *<i>spname</i>, int <i>spleng</i>,
int <i>sppricnt</i>, int <i>spseccnt</i>, int <i>spclass</i>)
<i><b>Where:</b></i><br/>
<i>hlbptr</i><br/>
Is a 4-byte pointer field containing the address of the HLB control block.<br/>
<i>spclass</i><br/>
Is a 4-byte integer field containing the storage class of the pool:<br/>
<b>0</b> = Residency of caller<br/>
<b>1</b> = 31-bit addressable<br/>
<b>2</b> = 24-bit addressable<br/>
This field is required for ALLOC, but not for FREE or LOCATE.<br/>
<i>spfunc</i><br/>
Is an 8-byte character field that specifies the function to be performed:<br/>
<b>ALLOC</b><br/>
Allocates the pool<br/>
<b>FREE</b> Frees the pool<br/>
<b>LOCATE</b><br/>
Locates the pool<br/>
<i>spleng</i><br/>
Is a 4-byte integer field containing the size of each cell in the pool. This field is
required for ALLOC, but not for FREE or LOCATE.<br/>
<i>spname</i><br/>
Is a varying length character field containing the name of the storage pool.
This field is required for all functions and provided by the caller. sppricnt
Is a 4-byte integer field containing the number of cells in the primary block.
This field is required only for ALLOC.<br/>
<i>spseccnt</i><br/>
Is a 4-byte integer field containing the number of cells in the secondary block.
This field is required only for ALLOC.<br/>
<i>sptoken</i><br/>
Is a 4-byte integer field to contain the token identifying the storage pool. This
field is returned for ALLOC and LOCATE for use with CNMCELL service.
This field is not required for FREE.<br/>
<b>Usage Notes:</b><br/>
		</p>
		<ol>
			<li>A storage cell within a pool is associated with the NetView subtask under
which it was allocated. It cannot be referenced from a task other than the one
with which it is associated.</li>
			<li>All storage pool names must be unique within a given task.</li>
		</ol>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Everything is OK.</td>
			</tr>
			<tr>
				<td>CNM_NOT_FOUND</td>
				<td>20</td>
				<td><i>spname</i> not found.</td>
			</tr>
			<tr>
				<td>CNM_NO_STORAGE</td>
				<td>24</td>
				<td>Nonzero return code from DSIGET macro.</td>
			</tr>
			<tr>
				<td>CNM_BAD_FUNC</td>
				<td>52</td>
				<td>Incorrect <i>spfunc</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_LENGTH</td>
				<td>88</td>
				<td><i>spleng</i> less than 4.</td>
			</tr>
						<tr>
				<td>CNM_DUPL_NAME</td>
				<td>104</td>
				<td><i>spname</i> already allocated. Allocation not done</td>
			</tr>
			<tr>
				<td>CNM_BAD_NAME</td>
				<td>108</td>
				<td>Length of spname greater than (>) 12.</td>
			</tr>
			<tr>
				<td>CNM_BAD_CLASS</td>
				<td>112</td>
				<td>Incorrect <i>spclass</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_ADDR</td>
				<td>160</td>
				<td>The storage pointed to by sptoken is not
addressable.</td>
			</tr>
			<tr>
				<td>CNM_BAD_PRI_COUNT</td>
				<td>192</td>
				<td>Incorrect <i>sppricnt</i>.</td>
			</tr>
			<tr>
				<td>CNM_BAD_SEC_COUNT</td>
				<td>196</td>
				<td>Incorrect <i>Incorrect spseccnt.</i>.</td>
			</tr>
						
		</table>
		<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler</i> for more information.</p>
		<h3><b>CNMQAPI (CNMOPREP): Resource Object Data Manager</b></h3>
		<p>
			The CNMQAPI service routine enables interaction with a specified resource object
data manager (RODM). All RODM API functions are supported through this
interface, including querying for data, changing data, and triggering methods.<br/>
Note: CNMQAPI applies only to those RODMs under the control of the DSIQTSK
task. Refer to the IBM Tivoli NetView for z/OS Automation Guide for an example of
managing your RODMs with DSIQTSK in a NetView automation scenario that
uses RODM.<br/>
The CNMQAPI routine syntax follows:<br/>
<b>PL/I CALL FORMAT:</b><br/>
CALL CNMQAPI(<i>hlbptr,qaacb,qatif,qaresp,qafunc,qawaitf,qawaitt</i>)<br/>
			<b>PL/I MACRO FORMAT:</b><br/>
CNMOPREP ACB(<i>qaacb</i>) TIF(<i>qatif</i>) RESPONSE(<i>qaresp</i>)
FUNCTION(<i>qafunc</i>) WAITF(<i>qawaitf</i>) WAITT(<i>qawaitt</i>)<br/>
<b>C INVOCATION:</b><br/>
void Cnmqapi (char*<i>qaacb</i>, char*<i>qatif</i>,char*<i>qaresp</i>,
char*<i>qafunc</i>, char*<i>qawaitf</i>, int *<i>qawaitt</i>)<br/>
<b><i>Where:</i></b><br/>
<i>hlbptr</i><br/>
Is a 4-byte field containing the address of the HLB control block.<br/>
<i>qaacb</i><br/>
Is a RODM access block following the format of the RODM API. For more
information about RODM, refer to the IBM Tivoli NetView for z/OS Resource
<i>Object Data Manager and GMFHS Programmer's Guide</i>.<br/> The access block contains these fields:<br/>
			<b>orname</b><br/>
This field specifies the name of the RODM that the caller wants to
access. If this field is blank (X'40'), the current runtime RODM is used.
The current runtime RODM is defined in the DSIQTSKI initialization
member in DSIPARM with the AO parameter on the REP keyword.
Refer to the<i> IBM Tivoli NetView for z/OS Administration Reference</i> for a
description of the DSIQTSKI keywords. The name is left-justified and
must be padded with blanks (X'40') to 8 characters.<br/>
<b>signon_token</b><br/>
Specifies the RODM signon token to be used within the call.<br/>
CNMQAPI ignores this field and fills it with the sign-on token
received by DSIQTSK when it initially connects to the RODM being
accessed. Refer to<i> IBM Tivoli NetView for z/OS Administration Reference</i>
for more information.<br/>
<b>user_appl_id</b><br/>
This field specifies the application name of the caller. CNMQAPI sets this field to the user application specified with the ID
parameter of the REP keyword (of DSIQTSKI) for the RODM being
accessed by this call. Refer to the<i> IBM Tivoli NetView for z/OS
Administration Reference</i> for a description of the DSIQTSKI keywords.<br/>
<i>qafunc</i><br/>
Is a varying length function block, following the format of the RODM API
function block, that describes the function requested and all required
parameters. The actual function block format depends on the function being
requested. Refer to the<i> IBM Tivoli NetView for z/OS Resource Object Data
Manager and GMFHS Programmer's Guide</i> for a description of the function block
format.<br/>
<i>qaresp</i><br/>
Is a response block following the format of the RODM API response block
control structure. Refer to IBM Tivoli NetView for z/OS Resource Object Data
Manager and GMFHS Programmer's Guide for information about the RODM
response block.<br/>
<i>qatif</i><br/>
Is a transaction information block following the format of the RODM API
transaction information block. Refer to <i>IBM Tivoli NetView for z/OS Resource
Object Data Manager and GMFHS Programmer's Guide </i>for a description of the
RODM API transaction information block.<br/>
<i>qawaitf</i><br/>
Specifies whether the request waits when a checkpoint is detected. If a
checkpoint is in progress for the specified RODM, the request is placed on a
queue until the checkpoint is complete. Upon checkpoint completion, the
request is processed. Valid values follow:<br/>
<b style="text-decoration: underline;">N</b> Do not wait for checkpoint completion. N is the default.<br/>
<b>Y</b> Wait for checkpoint completion.<br/>
<i>qawaitt</i><br/>
Is a 2-byte field that specifies the maximum time in seconds for which the call
is suspended if a checkpoint wait is to be started. The valid value range is
10—3600 seconds (1 hour). If you specify a time greater than 3600, 3600 is
used. If you do not specify this field, the default specified with the T keyword
of the DSIQTSKI initialization member for the DSIQTSK task is used.<br/>
			Refer to<i> IBM Tivoli NetView for z/OS Administration Referenc</i>e for more information.
<b>Usage Notes:</b><br/>
			
		</p>
		<ol>
			<li>An application can connect to RODM with an option specifying that RODM
can truncate its responses if the application response block is smaller than the
RODM response.<br/>
If this option is used, RODM truncates the response, does not save the
overflow data, and informs the application of the condition. This information is
sent in the return code and reason code in the transaction information block.
DSIQTSK connects using this option, saving CNMQAPI from having to deal
with overflow cleanup.</li>
			<li>CNMQAPI returns two sets of return codes.<br/>
The caller can use either of them. The first set is in the transaction information
block provided by the user upon invocation. These return codes are RODM
return codes and are documented for each possible function in the<i> IBM Tivoli
NetView for z/OS Resource Object Data Manager and GMFHS Programmer's Guide</i>.</li>
			<li>The second set is in the HLB.<br/>
The HLBRC field of the HLB contains a return code upon return from
CNMQAPI.</li>
			<li>APF-authorized command processors can access RODM without a password or
password phrase.<br/>
Provide a keyword for command processors that can be authority-checked to
control access to RODM.</li>
		</ol>
		<b>Return Codes:</b><br/>
		<table>
			<tr>
				<th>Return Code Name</th>
				<th>Value</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>CNM_GOOD</td>
				<td>0</td>
				<td>Successful.</td>
			</tr>
			<tr>
				<td>CNM_NO_PASSWORD</td>
				<td>8</td>
				<td>A command processor tried to access RODM
without specifying a password or password
phrase but was either not APF-authorized or
the APF-authorization code was not 1.</td>
			</tr>
			<tr>
				<td>CNM_NO_REPOS</td>
				<td>604</td>
				<td>RODM not under control of RODM access and
control component.</td>
			</tr>
			<tr>
				<td>CNM_API_FAILURE</td>
				<td>608</td>
				<td>CNMQAPI failure. Internal macro call
failure—might be storage.</td>
			</tr>
			<tr>
				<td>CNM_INVAL_PARMS</td>
				<td>612</td>
				<td>Incorrect parameters received.</td>
			</tr>
						<tr>
				<td>CNM_NO_STOR</td>
				<td>616</td>
				<td>No storage.</td>
			</tr>
			<tr>
				<td>CNM_TIMEOUT</td>
				<td>620</td>
				<td>Checkpoint in progress.</td>
			</tr>
			<tr>
				<td>CNM_BAD_OPR</td>
				<td>25000 + X</td>
				<td>Nonzero return code, X, from DSIOPR macro.</td>
			</tr>
			 
		</table>
		<p>Refer to IBM Tivoli NetView for z/OS Programming: Assembler for more information.</p>
		<h3><b>CNMRGS (CNMREGIST): Application Registration</b></h3>
		<p>
			The CNMRGS service routine enables registration and deregistration of any MS
application with the NetView MS transport, or any operations management served
application with the NetView operations management application. In addition, MS
applications can register as focal points while both MS applications and operations
management served applications can register as capable of receiving focal point
information. Refer to the <i>IBM Tivoli NetView for z/OS Application Programmer's Guide</i>
for more information about management services and remote operations.<br/>
		</p>
		
		
		
		
		
		
		

<div style="page-break-before:always; page-break-after:always"><div><p>The CNMRGS routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMRGS(<i>hlbptr,rgtype,rgappl,rgcmd,rgfpcat,rgfocpt,rgrepl,rgnotify,rgpri</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMREGIST TYPE(<i>rgtype</i>) APPL(<i>rgappl</i>) COMMAND(<i>rgcmd</i>)<br/>FPCATEGORY(<i>rgfpcat</i>) FOCALPOINT(<i>rgfocpt</i>)<br/>REPLACE(<i>rgrepl</i>) NOTIFY(<i>rgnotify</i>) PRI(<i>rgpri</i>)<br/></p>
<p><b>C INVOCATION</b>:<br/>void Cnmrgs(char *<i>rgtype</i>, char *<i>rgappl</i>, char *<i>rgcmd</i>, char *<i>rgfpcat</i>,<br/>char *<i>rgfocpt</i>, char *<i>rgrepl</i>, char *<i>rgnotify</i>, char *<i>rgpri</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>hlbptr<br/></i></p>
<p>Is a 4-byte pointer field containing the address of the HLB control block.<br/><i>rgappl<br/></i></p>
<p>Is an 8-byte character field that specifies the MS application or operations<br/>management served application being registered or deregistered.<br/>The application name can be one of the following:<br/>v An architecturally defined 4-byte value (padded with blanks to 8 bytes) for<br/></p>
<p>MS application programs.<br/>The following names are reserved by NetView and cannot be specified in a<br/>CNMRGS invocation:<br/><b>Reserved Name<br/></b></p>
<p><b>Hex Equivalent<br/>ALERT<br/></b></p>
<p>X'23F0F3F1'<br/><b>EP_OPS<br/></b></p>
<p>X'23F0F1F6'<br/><b>EP_SPCS<br/></b></p>
<p>X'23F0F1F4'<br/><b>HMON_DST<br/></b></p>
<p>X'30F0F8F5'<br/><b>HMON_OST<br/></b></p>
<p>X'30F0F8F4'<br/><b>LINKSERV<br/></b></p>
<p>X'23F0F3F5'<br/><b>MS_CAPS<br/></b></p>
<p>X'23F0F1F1'<br/><b>MDS_ROUT<br/></b></p>
<p>X'23F0F1F0'<br/><b>OPS_MGMT<br/></b></p>
<p>X'23F0F1F7'<br/><b>RMTCMD_R<br/></b></p>
<p>X'30F0F5F5'<br/></p>
<p><b>CNMRGS (CNMREGIST)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>RTMCMD_S<br/></b>X'30F0F7F0'<br/></p>
<p><b>RTMCMD_O<br/></b>X'30F0F7F2'<br/></p>
<p><b>R_BRIDGE<br/></b>X'30F0F5F9'<br/></p>
<p><b>SPCS </b>X'23F0F1F5'<br/><b>No character equivalent<br/></b></p>
<p>X'23F0F0F1'<br/><b>No character equivalent<br/></b></p>
<p>X'30F0F7F3'<br/>v A 1&#8211; to 8&#8211;character installation-defined name (padded with blanks). Use the<br/></p>
<p>EBCDIC characters 0-9 and A-Z (capitals only).<br/>The name STATUS is reserved for the NetView status focal point and is not<br/>allowed on a CNMRGS invocation.<br/></p>
<p><i>rgcmd<br/></i>Is an 8-byte character field that specifies the command procedure to be started<br/>when unsolicited or asynchronous solicited data is routed to the application.<br/>The NetView program verifies that the task has the authority to issue the<br/>command specified. This field is required for REGSMAPPL and<br/>REGOMSERVD.<br/></p>
<p><i>rgfocpt<br/></i>Is an 8-byte character field that specifies whether the MS application is a focal<br/>point application:<br/><b>NO </b>The MS application is not a focal point application. NO is the default<br/></p>
<p>for the PL/I macro format.<br/><b>YES </b>The MS application is a focal point application.<br/></p>
<p>If you do not specify the FOCALPOINT keyword when using the PL/I macro<br/>format for REGMSAPPL, the default value is used. Otherwise, this field is<br/>required for REGMSAPPL.<br/></p>
<p><i>rgfpcat<br/></i>Is an 8-byte character field that specifies the name of an application registered<br/>as a focal point application. This is the focal point category from which you<br/>want to receive information.<br/></p>
<p><b>Note: </b>NetView supplies three focal point applications, ALERT (X'23F0F3F1'),<br/>OPS_MGMT (X'23F0F1F7') and SPCS (X'23F0F1F5'). For REGOMSERVD, you<br/>can specify only OPS_MGMT for <i>rgfpcat</i>. For more information about the focal<br/>points, refer to the <i>IBM Tivoli NetView for z/OS Automation Guide</i>.<br/></p>
<p><i>rgnotify<br/></i>Is an 8-byte character field that specifies whether the MS or operations<br/>management served application receives session outage notification for LUs in<br/>contact with the MS transport.<br/><b>ALL </b>Indicates that the application receives an MDS-MU containing an SNA<br/></p>
<p>condition report with sense data every time the last SNASVCMG<br/>session has been lost. This notification is received even if the session<br/>outage is not related to an error.<br/></p>
<p><b>CNMRGS (CNMREGIST)<br/></b></p>
<p>Chapter 11. Service reference <b>243</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>ERROR<br/></b>Indicates that the application receives an MDS-MU containing an SNA<br/>condition report with sense data every time the last SNASVCMG<br/>session has been lost because of a session failure.<br/></p>
<p><b>NONE<br/></b>Indicates that the application does not receive session outage<br/>notification. NONE is the default for the PL/I macro format.<br/></p>
<p>If you do not specify the NOTIFY keyword when using the PL/I macro<br/>format, the default value is used. Otherwise, this field is required.<br/></p>
<p><i>rgpri<br/></i>Is an 8-byte character field that specifies the MQS priority for incoming<br/>requests. The MQS priority is used when the MS transport uses the MQS for<br/>processing any unsolicited MDS-MUs.<br/><b>HIGH </b>Processing begins after any NORMAL requests currently in progress<br/></p>
<p>completes, but before queued NORMAL or LOW requests.<br/><b>LOW </b>Processing is preempted by HIGH and NORMAL priority requests.<br/></p>
<p>This is the default.<br/><b>NORMAL<br/></b></p>
<p>Processing preempts a queue of LOW priority requests.<br/><b>TEST </b>CNMRGS queues the request based on the command priority of the<br/></p>
<p>receiving task. The command priority can be set using the OVERRIDE<br/>or DEFAULT commands. Refer to the NetView online help.<br/></p>
<p><i>rgrepl<br/></i>Is an 8-byte character field that specifies whether this registration is to<br/>supersede the previous registration for this application.<br/><b>NO </b>Specifies that this registration does not replace the current registration<br/></p>
<p>for this application.<br/><b>YES </b>Specifies that this registration replaces the current registration for this<br/></p>
<p>application. YES is the default for the PL/I macro format.<br/></p>
<p>If you do not specify the REPLACE keyword when using the PL/I macro<br/>format for REGMSAPPL or REGOMSERVD, the default value is used.<br/>Otherwise, this field is required for REGMSAPPL and REGOMSERVD.<br/></p>
<p><i>rgtype<br/></i>Is a 12-byte character field that specifies the type of request, as follows:<br/><b>DEREGMSAPPL<br/></b></p>
<p>Deregisters an MS application from the NetView MS transport.<br/><b>DEREGOMSERVD<br/></b></p>
<p>Deregisters an operations management served application from<br/><b>REGMSAPPL<br/></b></p>
<p>Registers an MS application to the NetView MS transport.<br/><b>REGOMSERVD<br/></b></p>
<p>Registers a second-level application to operations management.<br/></p>
<p><b>Usage Notes:<br/></b>1. You can register an application as both an MS application and an operations<br/></p>
<p>management served application.<br/></p>
<p><b>CNMRGS (CNMREGIST)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>2. When you specify that an MS application is a focal point, the focal point<br/>category name is the application name specified in <i>rgappl</i>.<br/></p>
<p>3. Any registered application that was once a focal point application continues to<br/>receive focal point data from any application that did not attempt to send data<br/>while it was deregistered. To recognize that an application is no longer a focal<br/>point, the sending application must attempt to send data to a focal point<br/>application that has been deregistered.<br/></p>
<p>4. NetView determines the task where an application receives an MDS-MU as<br/>follows:<br/>v For an MDS reply, the receiving task is the task under which the requesting<br/></p>
<p>application is running.<br/>v For an MDS request, the receiving task is the task from which CNMRGS is<br/></p>
<p>started for the receiving application.<br/>v For an MDS error message:<br/></p>
<p>&#8211; If the AUOWC matches an active AUOWC in the active transaction list:<br/>- For an outgoing request, the receiving task is the task under which the<br/></p>
<p>requesting application is running.<br/>- For an incoming request, the receiving task is the task under which the<br/></p>
<p>receiving application is running.<br/>&#8211; If the AUOWC does not match an active AUOWC, the receiving task is<br/></p>
<p>the task from which CNMRGS is started for the receiving application.<br/>5. You can change the task under which CNMRGS was started by reregistering<br/></p>
<p>the application from the desired task and specifying YES for <i>rgrepl</i>.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Successful registration/deregistration.<br/>CNM_NOT_FOUND 20 Deregistration unsuccessful. <i>rgappl </i>not<br/></p>
<p>registered.<br/>CNM_NO_STORAGE 24 Nonzero return code from DSIGET macro.<br/>CNM_NOT_IN_ASYNC 44 Deregistration unsuccessful. Issued from an<br/></p>
<p>exit.<br/>CNM_DUPL_NAME 104 Registration unsuccessful. <i>rgappl </i>already<br/></p>
<p>registered.<br/>CNM_BUSY 472 Registration/deregistration unsuccessful.<br/></p>
<p>Queues are in use.<br/>CNM_BAD_APPL_NAME 476 Registration/deregistration unsuccessful.<br/></p>
<p><i>rgappl </i>syntax incorrect.<br/>CNM_APPL_NAME_RSTD 480 Registration/deregistration unsuccessful.<br/></p>
<p><i>rgappl </i>restricted.<br/>CNM_BAD_FPCAT_NAME 484 Registration/deregistration unsuccessful.<br/></p>
<p><i>rgfpcat </i>syntax incorrect.<br/>CNM_BAD_FPCAT_CHOICE 488 Registration unsuccessful. <i>rgfpcat </i>has an<br/></p>
<p>incompatible value.<br/>CNM_BAD_REG_TYPE 492 Incorrect <i>rgtype</i>.<br/>CNM_BAD_FOCALPT_VALUE 496 Incorrect <i>rgfocpt</i>.<br/>CNM_CANT_BE_FOCALPT 500 Registration unsuccessful. <i>rgfocpt </i>has an<br/></p>
<p>incompatible value.<br/></p>
<p><b>CNMRGS (CNMREGIST)<br/></b></p>
<p>Chapter 11. Service reference <b>245</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Return Code Name Value Description<br/></b>CNM_BAD_REPLACE_VALUE 504 Incorrect <i>rgrepl</i>.<br/>CNM_BAD_PRI_VALUE 512 Incorrect <i>rgpri </i>value specified. Value must<br/></p>
<p>be blank, LOW, NORMAL, HIGH, or TEST.<br/>CNM_BAD_NOTIFY 592 Incorrect <i>rgnotify </i>value specified.<br/>CNM_BAD_CES + X 9000 + X Nonzero return code, X, from DSICES<br/></p>
<p>macro using <i>rgcmd</i>.<br/></p>
<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.<br/></p>
<p><b>CNMSCAN (CNMSSCAN): Parse or Convert Character<br/>String&#8211;PL/I Only<br/></b></p>
<p>You can use the CNMSCAN service routine to extract data from an input string<br/>and assign the extracted data to one or more receiving variables. The input string<br/>is scanned from left to right and is interpreted according to the specifications<br/>defined by the format string. Each receiving variable must have the same data type<br/>as its corresponding type specifier in the format string. You can specify up to 10<br/>receiving variables in the argument list. The number of fields successfully parsed<br/>and converted is returned to you in <i>panumfld</i>.<br/></p>
<p>When the first format specification is found, the value of the first input field is<br/>converted according to the first format specification and stored in the first<br/>receiving variable in the argument list. When the second format specification is<br/>found, the value of the second input field is converted according to the second<br/>format specification and stored in the second receiving variable in the argument<br/>list. This process continues until all of the format specifications in the format string<br/>are processed.<br/></p>
<p>The CNMSCAN routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMSCAN(<i>hlbptr,pastring,pattern,panumfld,pafld1,...,pafld10</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMSSCAN DATA(<i>pastring</i>) FORMAT(<i>pattern</i>) COUNT(<i>panumfld</i>)<br/>P1(<i>pafld1</i>)...P10(<i>pafld10</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>hlbptr<br/></i></p>
<p>Is a 4-byte pointer field containing the address of the HLB control block.<br/><i>pafld1<b></b></i><b>,.....,</b><i>pafld10<br/></i></p>
<p>Is a list of receiving variables. The last variable named in this list receives the<br/>value of the last input field parsed and converted according to the last<br/>specification in the format string. Declare each of the variables named in this<br/>list to have the same data type as its corresponding type specifier in the format<br/>string. You can specify up to 10 variables to receive parsed and converted data.<br/></p>
<p><i>panumfld<br/></i>Is a 4-byte integer field containing the number of fields successfully parsed<br/>and converted. This field is returned to you.<br/></p>
<p><b>CNMRGS (CNMREGIST)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><i>pastring<br/></i>Is a varying length character field containing the input string to be parsed and<br/>converted.<br/></p>
<p><i>pattern<br/></i>Is a varying length character field containing the format specifications. The<br/>format string (<i>pattern</i>) determines how the data elements in the input string<br/>(<i>pastring</i>) are parsed and converted.<br/></p>
<p><b>Usage Notes:<br/></b>1. The format string consists of a series of format specifications that are defined as<br/></p>
<p>follows:<br/>v The character %, which designates the beginning of each format specification.<br/></p>
<p>(Required for each format specification.)<br/>v The character *, which indicates that the data in the corresponding input<br/></p>
<p>field is skipped. No assignment is made to a receiving variable. (Optional)<br/>v A numerical value that defines a maximum field width to scan in the input<br/></p>
<p>string. (Optional)<br/>v The character h (halfword) or l (long or fullword), which indicates the size of<br/></p>
<p>the argument that the value of the parsed or converted input data is<br/>assigned. (Optional)<br/></p>
<p>v Any number of white-space characters, which can be interspersed within or<br/>between format specifications for readability. However, do not insert blanks<br/>between braces ({}). (Optional)<br/></p>
<p>v The type specifier for the parsed or converted input data to be stored in the<br/>receiving variable. (Required)<br/></p>
<p>2. The type specifier directs the conversion of the input field. CNMSCAN places<br/>the result in the receiving variable, unless you specify assignment suppression<br/>with an *. An input field is a string of characters other than spaces, unless the<br/>type specifier is a <b>c </b>or { }. The input field extends to the next character that<br/>does not meet the criteria of the type specifier, or until the width of the field, if<br/>specified, is reached.<br/></p>
<p>3. The type specifier determines the interpretation of the next input field. If the<br/>input field does not meet this expectation, CNMSCAN returns to its caller.<br/>Valid specifiers are:<br/><b>c </b>Expect any character. Space characters that are ordinarily skipped are<br/></p>
<p>read. Specify a field width to parse and convert more than one<br/>character. For example, %3c retrieves the next 3 characters of the input<br/>string. To skip over spaces before obtaining a character, use %1s. See<br/>the description that follows on the type specifier <b>s</b>.<br/></p>
<p><b>Note: </b>The receiving variable to contain the character string result must<br/>be declared as a fixed-length character string.<br/></p>
<p><b>d </b>Expect a decimal value. Input is an optionally signed sequence of<br/>decimal digits. Any spaces in the input string preceding the decimal<br/>digits are skipped. The decimal digits are delimited by the next<br/>non-decimal character in the input string.<br/></p>
<p><b>n </b>A data element is not parsed and converted from the input string. The<br/>value stored is the number of characters successfully read (including<br/>blanks) from the input string up to that point in the call to CNMSCAN.<br/></p>
<p><b>Note: </b>If the end of the input string occurs before the %n is reached, the<br/>value stored is 0.<br/></p>
<p><b>CNMSCAN (CNMSSCAN)<br/></b></p>
<p>Chapter 11. Service reference <b>247</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>s </b>Expect a character string. Any spaces in the input string preceding the<br/>character string are skipped. The character string is delimited by a<br/>space. If you do not specify a field width, the field width defaults to<br/>the length of the string.<br/></p>
<p><b>Note: </b>The receiving variable to contain the character string result must<br/>be declared as a varying length character string.<br/></p>
<p><b>u </b>Expect an unsigned decimal value. Any spaces in the input string<br/>preceding the decimal digits are skipped. The decimal digits are<br/>delimited by the next nondecimal character in the input string.<br/></p>
<p><b>x </b>Expect a hexadecimal value. Input is an optionally signed sequence of<br/>hexadecimal digits. Any spaces in the input string preceding the<br/>hexadecimal digits are skipped. The hexadecimal digits are delimited<br/>by the next non-hexadecimal character in the input string.<br/></p>
<p><b>{} </b>Expect a string that is not delimited by spaces. The character string is<br/>set within the braces. The corresponding input field is read to the first<br/>character that does <i>not </i>appear between braces ({}). If the first character<br/>is &#172; (or &#8216;5F&#8217;x), the effect is reversed. The input field is read to the first<br/>character that appears between braces ({}). Do not insert blanks<br/>between braces ({}) unless this is the desired effect.<br/><b>{&#172;} </b>Parses until the end of the string.<br/><b>{&#172;a} </b>Parses until the character <b>a </b>is found.<br/><b>{a} </b>Parses until any character other than an <b>a </b>is found.<br/><b>{} </b>Parses until any character is found.<br/></p>
<p><b>Note: </b>The receiving variable to contain the character string result must<br/>be declared as a varying length character string.<br/></p>
<p>4. If your format string specifies fewer data elements to be parsed and converted<br/>than your input string contains, the remaining data elements in the input string<br/>are ignored.<br/></p>
<p>5. CNMSCAN returns when it encounters a format specification it does not expect<br/>or when it reaches the end of the input string.<br/></p>
<p>6. If you invoke CNMSCAN using the PL/I call format and all 10 <i>paflds </i>are not<br/>specified, a warning message is issued at compile time.<br/></p>
<p>7. You can use CNMSCAN only in an HLL command processor or installation exit<br/>routine written in PL/I.<br/></p>
<p>8. The PARSEL2R command provides a function similar to CNMSCAN. However,<br/>because of its conversion capabilities, CNMSCAN is more suitable to HLL<br/>command processors.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Everything is OK.<br/>CNM_BAD_ADDR 160 The storage pointed to by <i>panumfld </i>or <i>pafld1,...,pafld10<br/></i></p>
<p>is not addressable.<br/></p>
<p><b>CNMSCAN (CNMSSCAN)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>CNMSCOP (CNMSCOPECK): Command, Keyword, and Value<br/>Authorization Checking<br/></b></p>
<p>The CNMSCOP service routine determines whether the user is authorized to issue<br/>a specific command, keyword, and value combination from a particular operator<br/>ID. The security check is based on the authority of the operator ID of the task<br/>invoking CNMSCOP. The type of authorization checking that is performed is<br/>determined by the setting of the CMDAUTH keyword on the REFRESH command<br/>or by the setting of the SECOPTS.CMDAUTH statement in the CNMSTYLE<br/>member. Only NetView authorization checking is performed. No attempt is made<br/>to determine if a resource is in the span of control of the task (operator).<br/></p>
<p>The CNMSCOP routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMSCOP(<i>hlbptr,sccmd,sckwd,scvalue</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMSCOPECK VERB(<i>sccmd</i>) KEYWORD(<i>sckwd</i>) VALUE(<i>scvalue</i>)<br/></p>
<p><b>C INVOCATION</b>:<br/>void Cnmscop(char *<i>sccmd</i>, char *<i>sckwd</i>, char *<i>scvalue</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>hlbptr<br/></i></p>
<p>Is a 4-byte pointer field containing the address of the HLB control block.<br/><i>sccmd<br/></i></p>
<p>Is an 8-byte character field that specifies the verb of the command to be<br/>checked for authorization. Blanks or (*) imply that the command verb that<br/>started the HLL command processor is used. This field is required.<br/></p>
<p><i>sckwd<br/></i>Is an 8-byte character field that specifies a keyword of the command to be<br/>checked for authorization. Blanks or (*) imply that no specific keyword is<br/>checked.<br/></p>
<p><i>scvalue<br/></i>Is an 8-byte character field that specifies a value of <i>sckwd </i>to be checked for<br/>authorization. Blanks or (*) imply that no specific keyword value is to be<br/>checked.<br/></p>
<p><b>Usage Notes:<br/></b>1. Authorization to access commands, keywords, and keyword values is defined<br/></p>
<p>by the setting of the CMDAUTH keyword on the REFRESH command or by<br/>the setting of the SECOPTS.CMDAUTH statement in the CNMSTYLE member.<br/>For more information, refer to <i>IBM Tivoli NetView for z/OS Security Reference</i>.<br/></p>
<p>2. CNMSCOP does not check the validity of a command. Use it only to verify<br/>whether an operator has authorization to issue a particular command.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Everything is OK.<br/>CNM_NO_STORAGE 24 Nonzero return code from DSIGET macro.<br/></p>
<p><b>CNMSCOP (CNMSCOPECK)<br/></b></p>
<p>Chapter 11. Service reference <b>249</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Return Code Name Value Description<br/></b>CNM_COMMAND_NA 132 <i>sccmd </i>not authorized.<br/>CNM_KEYWORD_NA 136 <i>sckwd </i>not authorized.<br/>CNM_VALUE_NA 140 <i>scvalue </i>not authorized.<br/>CNM_BAD_COMMAND 144 Incorrect syntax of <i>sccmd </i>or <i>sccmd </i>was not found.<br/></p>
<p>Check for length greater than (&gt;) 8 or incorrect<br/>characters in <i>sccmd</i>. <i>sccmd </i>might be incorrectly<br/>defined. See usage notes if CNMSCOP was<br/>started from an HLL installation exit routine.<br/></p>
<p>CNM_BAD_KEYWORD 148 VALUE (<i>scvalue</i>) was specified without a<br/>keyword (<i>sckwd</i>). <i>sckwd </i>must be specified when<br/><i>scvalue </i>is specified.<br/></p>
<p>CNM_SAF_FAILURE 624 An unexpected return code was received from<br/>SAF.<br/></p>
<p>CNM_KWRD_VAL_NA 628 The keyword and value combination specified is<br/>not authorized. This return code can only be<br/>issued when a command authorization table or<br/>an SAF product is being used for command<br/>authorization.<br/></p>
<p>CNM_BAD_SEC_ENVIR 632 Authorization to issue this command, keyword,<br/>or keyword and value combination is not granted<br/>because the security environment for the operator<br/>cannot be established. Message BNH239E is<br/>issued when this condition is first encountered to<br/>provide the security product return code<br/>information. Message BNH273I is issued when<br/>the condition has been corrected.<br/></p>
<p>CNM_TBL_FAILURE 636 Authorization to issue this command, keyword,<br/>or keyword and value combination is not granted<br/>because an unexpected return code was received<br/>from the command authorization table. Message<br/>BNH199E is issued indicating the command<br/>identifier and the operator ID being checked.<br/></p>
<p>CNM_NO_SEC_INFO 640 Authorization to issue this command, keyword,<br/>or keyword and value combination is not granted<br/>because the NetView internal security<br/>information containing the source ID of the<br/>command cannot be found. Message BNH277E is<br/>issued identifying the command, keyword or<br/>value being checked.<br/></p>
<p>CNM_NO_OP_INFO 644 Authorization to issue this command, keyword,<br/>or keyword and value combination is not granted<br/>because the source ID is blank in the NetView<br/>internal security information. Message BNH277E<br/>is issued identifying the command, keyword or<br/>value being checked.<br/></p>
<p>CNM_BAD_CES + X 9000 + X Nonzero return code, X, from DSICES macro.<br/>CNM_BAD_KVS + X 11000 + X Nonzero return code, X, from DSIKVS macro.<br/></p>
<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.<br/></p>
<p><b>CNMSCOP (CNMSCOPECK)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>CNMSMSG (CNMSENDMSG): Send Message or Command<br/></b>Use the CNMSMSG service routine to send a message or command to specific<br/>destinations in your network.<br/></p>
<p>The CNMSMSG routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMSMSG(<i>hlbptr,smtext,smmsgtyp,smdestyp,smdestid</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMSENDMSG DATA(<i>smtext</i>) MSGTYPE(<i>smmsgtyp</i>)<br/>DESTTYPE(<i>smdestyp</i>) DEST(<i>smdestid</i>)<br/></p>
<p><b>C INVOCATION</b>:<br/>void Cnmsmsg(void *<i>smtext</i>, char *<i>smmsgtyp</i>, char *<i>smdestyp</i>,<br/>char *<i>smdestid</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>hlbptr<br/></i></p>
<p>Is a 4-byte pointer field containing the address of the HLB control block.<br/><i>smdestid<br/></i></p>
<p>Is an 8-byte character field that specifies the destination ID. This is a required<br/>operand when <i>smdestyp </i>is EXTLOG, SEQLOG, TASK, or OPCLASS.<br/>When <i>smdestyp </i>is EXTLOG, SEQLOG, or TASK, <i>smdestid </i>is the name of the<br/>destination task. You can use an asterisk (*) to imply &#8220;self&#8221; when <i>smdestyp </i>=<br/>TASK. Specifying <i>smdestid </i>= * is the same as issuing CNMSMSG with <i>smdestyp<br/></i>= OPER and <i>smdestid </i>= null.<br/>When <i>smdestyp </i>is OPCLASS, <i>smdestid </i>is the group ID of a particular group of<br/>operators defined by the ASSIGN command. Refer to the ASSIGN command in<br/>the NetView online help for more information.<br/></p>
<p><b>Note: </b>PPT is accepted as a synonym for the primary POI task (<i>xxxxx</i>PPT)<br/>where <i>xxxxx </i>is the domain ID in the local NetView program.<br/></p>
<p><i>smdestyp<br/></i>Is an 8-byte character field that specifies the destination type. This is a required<br/>operand. Possible values follow:<br/><b>AUTHRCV<br/></b></p>
<p>Authorized receiver<br/><b>EXTLOG<br/></b></p>
<p>External system management facility (SMF) log<br/><b>NETVLOG<br/></b></p>
<p>NetView log<br/><b>OPCLASS<br/></b></p>
<p>All operators in group<br/><b>OPER </b>Operator task invoking this service routine<br/><b>SEQLOG<br/></b></p>
<p>Sequential log<br/><b>SYSOP<br/></b></p>
<p>System console<br/></p>
<p><b>CNMSMSG (CNMSENDMSG)<br/></b></p>
<p>Chapter 11. Service reference <b>251</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>TASK </b>Another task<br/><i>smmsgtyp<br/></i></p>
<p>Is an 8-byte character field that specifies the message type. This is a required<br/>operand. The possible values follow:<br/><b>COMMAND<br/></b></p>
<p>Is the command to be run. (The command is asynchronously scheduled<br/>to be run.)<br/></p>
<p><b>DATA </b>Is the nonprintable data in response to REQUEST.<br/>NetView places a process ID in the origin block (ORIGBLCK). This ID<br/>must be included at the beginning of the returned data. This process<br/>ID is used to route data to the correct instance of an HLL command<br/>processor or installation exit routine if there are multiple activations of<br/>the same HLL command processor or installation exit routine. The data<br/>returned from CNMSMSG with <i>smmsgtyp</i>=DATA can be read by<br/>CNMGETD from the data queue (DATAQ).<br/></p>
<p><b>MSG </b>Single line message. ORIG_LINE_TYPE=&#8217; &#8217;<br/><b>MSG_C<br/></b></p>
<p>Control line message.ORIG_LINE_TYPE=&#8217;C&#8217;<br/><b>MSG_D<br/></b></p>
<p>Data line message.ORIG_LINE_TYPE=&#8217;D&#8217;<br/><b>MSG_E<br/></b></p>
<p>End of multiline message. ORIG_LINE_TYPE=&#8217;E&#8217;<br/><b>MSG_F<br/></b></p>
<p>MSG_D and MSG_E combined. ORIG_LINE_TYPE=&#8217;F&#8217;<br/><b>MSG_L<br/></b></p>
<p>Label line message. ORIG_LINE_TYPE=&#8217;L&#8217;<br/><b>REQUEST<br/></b></p>
<p>Is the request for data. REQUEST is similar to COMMAND except the<br/>command to run is the name of the HLL command processor that is to<br/>return data through CNMSMSG with <i>smmsgtyp</i>=DATA.<br/></p>
<p><i>smtext<br/></i>Is a varying length character field containing the message text. This is a<br/>required operand. The values are explained as follows:<br/>v If <i>smmsgtyp </i>is MSG, MSG_C, MSG_L, MSG_D, MSG_E, or MSG_F, <i>smtext </i>is<br/></p>
<p>the text of the message.<br/>v If <i>smmsgtyp </i>is COMMAND, <i>smtext </i>is either a command procedure name or a<br/></p>
<p>NetView command.<br/>v If <i>smmsgtyp </i>is REQUEST, the first token must be the name of the HLL<br/></p>
<p>command processor that sends a reply to the request. NetView concatenates<br/>the process ID to the end of <i>smtext </i>and the request for data is sent. As a<br/>result, if <i>smtext </i>contains input for the target task, the target task must take<br/>into account that the last 8 bytes of CMDBUF are always the process ID.<br/></p>
<p>v If <i>smmsgtyp </i>is DATA, the process ID must be concatenated with the data.<br/>Specify <i>smtext </i>as follows:<br/>smtext = ORIGIN-&gt;ORIG_PROCESS||&#8217;text&#8217;<br/></p>
<p>Table 17 on page 253 shows message and destination type combinations that are<br/>not valid.<br/></p>
<p><b>CNMSMSG (CNMSENDMSG)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><i>Table 17. Incorrect Message and Destination Type Combinations<br/><b></b></i><b>OPER TASK SYSOP NETVLOG EXTLOG SEQLOG AUTHRCV OPCLASS<br/></b></p>
<p>MSG<br/>MSG_C x x x<br/>MSG_L x x x<br/>MSG_D x x x<br/>MSG_E x x x<br/>MSG_F x x x<br/>COMMAND x x x x x x x<br/>REQUEST x x x x x x x<br/>DATA x x x x x x x<br/></p>
<p><b>Usage Notes:<br/></b>1. The amount of data that can be sent by CNMSMSG varies based on the value<br/></p>
<p>of <i>smmsgtyp</i>. The following limits are enforced for the <i>smmsgtyp </i>values.<br/><b>MSG </b>32000 bytes<br/><b>MSG_C<br/></b></p>
<p>32000 bytes<br/><b>MSG_L<br/></b></p>
<p>32000 bytes<br/><b>MSG_D<br/></b></p>
<p>32000 bytes<br/><b>MSG_E<br/></b></p>
<p>32000 bytes<br/><b>MSG_F<br/></b></p>
<p>32000 bytes<br/><b>COMMAND<br/></b></p>
<p>31998 bytes<br/><b>REQUEST<br/></b></p>
<p>31989 bytes<br/><b>DATA </b>32500 bytes<br/></p>
<p>2. Multiline messages are treated as single line messages when CNMSMSG is<br/>started from DSIEX02A.<br/></p>
<p>3. CNMSMSG generates a return code of CNM_BAD_INVOCATION when started<br/>from DSIEX04 or DSIEX09. You can invoke CNMSMSG from DSIEX02A only<br/>when <i>smdestyp </i>is TASK and <i>smmsgtyp </i>is one of the message options.<br/>COMMAND and REQUEST are not permitted as <i>smmsgtyp </i>values. When<br/>invoking CNMSMSG from DSIEX02A. you can also send a command to<br/>another task, in a way similar to EXCMD, by specifying<br/><i>smmsgtyp</i>=COMMAND, <i>smdestyp</i>=TASK, and the desired <i>smtext </i>and <i>smdestid</i>.<br/></p>
<p>4. Messages sent to a console with <i>smmsgtyp </i>= MSG_C, MSG_D, MSG_E, MSG_F,<br/>or MSG_L are truncated if they are longer than the screen width of that<br/>console.<br/></p>
<p><b>CNMSMSG (CNMSENDMSG)<br/></b></p>
<p>Chapter 11. Service reference <b>253</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>5. You can display as many control (MSG_C) and label (MSG_L) lines on a<br/>console as desired. However, a maximum of six control or label lines are held<br/>on the screen if the data lines for that multiline message cause the screen to<br/>wrap.<br/></p>
<p>6. Do not invoke CNMSMSG with <i>smdestyp </i>= OPER while holding a lock. The<br/>operator task can be running with autowrap off, and the HLL command<br/>processor or installation exit routine might hang waiting for the operator to<br/>clear the screen, thus holding the lock for an indefinite period.<br/></p>
<p>7. When the SECOPTS.AUTHCHK statement in the CNMSTYLE member specifies<br/>SOURCEID, or the REFRESH command specifies SECOPTS=AUTHCHK,<br/>command authorization checking is performed against the original source of<br/>the command rather than against the environment in which the command runs.<br/>When CNMSMSG is used to queue a command, a SOURCEID is also queued.<br/>If the invoker is running in an installation exit, the SOURCEID is the name of<br/>the task (TVBOPID) under which the installation exit that started CNMSMSG is<br/>running. If CNMSMSG is started in a command processor, the SOURCEID is<br/>the ID of the task under which the command is issued or the existing<br/>SOURCEID at the time the command was queued. For more information about<br/>SOURCEID, refer to the <i>IBM Tivoli NetView for z/OS Administration Reference</i>.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Everything is OK.<br/>CNM_BAD_INVOCATION 4 Not started from an allowed installation exit.<br/>CNM_NO_STORAGE 24 Nonzero return code from DSIGET macro.<br/>CNM_BAD_LENGTH 88 <i>smtext </i>is too long.<br/>CNM_BAD_MSGTYP 116 Incorrect message type.<br/>CNM_BAD_DESTYPE 120 Incorrect destination type.<br/>CNM_TYP_CONFLICT 124 Conflict between message and destination type.<br/>CNM_LOG_INACTIVE 216 DSIWLS failure. Log was inactive.<br/>CNM_TASK_INACTIVE 220 DSIMQS failure. Task was inactive.<br/>CNM_BAD_MQS + X 1000 + X Bad return code, X, from DSIMQS.<br/>CNM_BAD_WLS + X 6000 + X Bad return code, X, from DSIWLS.<br/>CNM_BAD_PSS + X 7000 + X Bad return code, X, from DSIPSS.<br/>CNM_BAD_WTO + X 8000 + X Bad return code, X, from DSIWCS.<br/></p>
<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.<br/></p>
<p><b>CNMSMU (CNMSENDMU): Send Message Unit<br/></b>The CNMSMU service routine allows MS applications and operations management<br/>served applications in NetView to send data to a specified target. You can invoke<br/>CNMSMU only in applications registered through CNMRGS or the REGISTER<br/>command.<br/></p>
<p>The data is sent in the form of an MDS-MU. The invocation can supply:<br/>v A completely built MDS-MU<br/>v An MDS-MU that is missing one or more of the following:<br/></p>
<p>&#8211; A unit of work correlator<br/></p>
<p><b>CNMSMSG (CNMSENDMSG)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&#8211; An origin NETID<br/>&#8211; An origin LUNAME<br/></p>
<p>v Data and sufficient other fields for the service routine to build an MDS-MU<br/>header.<br/></p>
<p><b>Note: </b>Refer to the SNA library for more information about MDS-MUs.<br/></p>
<p>The CNMSMU service routine builds the necessary NetView MQS buffer with the<br/>specified data and queues it for the NetView MS transport.<br/></p>
<p>The CNMSMU routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMSMU(<i>hlbptr,sudtype,sudata,susupcor,sucorrar,sutimout,susynch,<br/>surplcmd,suoappl,sudstnet,sudstlu,sudstapl,sumutype,supri</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMSENDMU DATATYPE(<i>sudtype</i>) DATA(<i>sudata</i>)<br/>SUPPCORREL(<i>susupcor</i>) CORRELAREA(<i>sucorrar</i>)<br/>TIMEOUT(<i>sutimout</i>) SYNCH(<i>susynch</i>)<br/>REPLYCMD(<i>surplcmd</i>) ORIGAPPL(<i>suoappl</i>)<br/>DESTNET(<i>sudstnet</i>) DESTLU(<i>sudstlu</i>)<br/>DESTAPPL(<i>sudstapl</i>) MUTYPE(<i>sumutype</i>)<br/>PRI(<i>supri</i>)<br/></p>
<p><b>C INVOCATION</b>:<br/>void Cnmsmu(char *<i>sudtype</i>, void *<i>sudata</i>, void *<i>susupcor</i>,<br/>void *<i>sucorrar</i>, int <i>sutimout</i>, char *<i>susynch</i>,<br/>char *<i>surplcmd</i>, char *<i>suoappl</i>, char *<i>sudstnet</i>,<br/>char *<i>sudstlu</i>, char *<i>sudstapl</i>, int <i>sumutype</i>,<br/>char *<i>supri</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>hlbptr<br/></i></p>
<p>Is a 4-byte character field containing the address of the HLB control block.<br/><i>sucorrar<br/></i></p>
<p>Is a 53-byte area in which a new unit of work correlator (X'1549') GDS variable<br/>is created and returned by the CNMSMU service routine.<br/>If you specify <i>sucorrar </i>for MDSMU, NetView creates the unit of work<br/>correlator in this area and inserts it into the specified MDS-MU while copying<br/>it into the buffer for the MS transport. If you omit <i>sucorrar</i>, the MDS-MU must<br/>be complete and ready to be transmitted as supplied.<br/>For a NONMDSMU, specify either <i>sucorrar </i>or <i>susupcor</i>. If you specify <i>sucorrar</i>,<br/>CNMSMU creates the UOWC GDS variable in this area and uses it in building<br/>the MDS header.<br/></p>
<p><i>sudata<br/></i>Is a varying length character field containing the data being sent. For either<br/>MDSMU or NONMDSMU, the first 2 bytes must contain the entire length of<br/>the data and the next 2 bytes must contain the key.<br/></p>
<p><i>sudstapl<br/></i>Is an 8-byte character field that specifies the destination application name.<br/>The application name can be one of the following:<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>
<p>Chapter 11. Service reference <b>255</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>v An architecturally defined 4-byte value (padded with blanks to 8 bytes) for<br/>MS application programs.<br/></p>
<p>v A 1&#8211;8 character installation-defined name (padded with blanks). Use the<br/>EBCDIC characters 0&#8211;9 and A&#8211;Z (capitals only).<br/></p>
<p>v A 1&#8211;8 character NetView-reserved name (padded with blanks) that<br/>represents an architecturally defined 4-byte value. NetView-reserved names<br/>and the corresponding values follow:<br/><b>ALERT<br/></b></p>
<p>X'23F0F3F1'<br/><b>EP_ALERT<br/></b></p>
<p>X'23F0F3F0'<br/><b>EP_OPS<br/></b></p>
<p>X'23F0F1F6'<br/><b>MS_CAPS<br/></b></p>
<p>X'23F0F1F1'<br/><b>OPS_MGMT<br/></b></p>
<p>X'23F0F1F7'<br/>This field is required for NONMDSMU.<br/></p>
<p><i>sudstlu<br/></i>Is an 8-byte character field that specifies the LU name or VTAM CP name of<br/>the destination LU or VTAM CP. If the destination LU is not specified, then the<br/>default is the CP. Specify the 1&#8211;8 character LU or VTAM CP name (padded<br/>with blanks to 8 characters) beginning with an EBCDIC character 0&#8211;9 and A&#8211;Z<br/>(capitals only), @, #, or $, and followed by EBCDIC characters 0&#8211;9 and A&#8211;Z<br/>(capitals only).<br/>This is a required field for NONMDSMUs.<br/></p>
<p><b>Note: </b>For sends within the same NetView, the send services always fills in the<br/>NetView LU name as the origin LU.<br/></p>
<p><i>sudstnet<br/></i>Is an 8-byte character field that specifies the ID of the network of the<br/>destination LU or VTAM CP. Specify the 1&#8211;8 character NETID (padded with<br/>blanks to 8 characters) beginning with an EBCDIC character 0&#8212;9 and A&#8212;Z<br/>(capitals only), @, #, or $, and followed by EBCDIC characters 0&#8212;9 and A&#8212;Z<br/>(capitals only). The value of this field defaults to the network name that VTAM<br/>determines based on the LU name or VTAM CP name of the remote node<br/>(specified with the <i>hsdstlu </i>field) if:<br/>v You specify blanks for this field for the PL/I call format.<br/>v You do not specify the DESTNET keyword when using the PL/I macro<br/></p>
<p>format.<br/>v You specify blanks for this field for the C invocation format.<br/></p>
<p><i>sudtype<br/></i>Is an 8-byte character field indicating whether the data item specified in the<br/><i>sudata </i>keyword is an MDS-MU or a non-MDS-MU.<br/><b>MDSMU<br/></b></p>
<p>Indicates that the <i>sudata </i>is an MDS-MU. MDSMU is the default for the<br/>PL/I macro format.<br/></p>
<p><b>NONMDSMU<br/></b>Indicates that the <i>sudata </i>is not a complete MDS-MU because it does<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>not contain an MDS-MU header. The CNMSMU service routine<br/>envelopes this data in an MDS-MU before sending it.<br/></p>
<p>If you do not specify the DATATYPE keyword in the PL/I macro format, the<br/>default value is used.<br/></p>
<p><i>sumutype<br/></i>Is a 4-byte integer field that specifies the index number that identifies the type<br/>of MDS-MU to build. The type identifies whether the MDS-MU is a request, a<br/>reply, or an error message, and whether additional messages are expected.<br/>Types defined as constants are as follows:<br/><b>1 </b>REQUEST_WITH_REPLY<br/><b>2 </b>REQUEST_WITHOUT_REPLY<br/><b>3 </b>REPLY_ONLY<br/><b>4 </b>REPLY_NOTLAST<br/><b>5 </b>REPLY_LAST<br/><b>6 </b>ERROR_MESSAGE<br/>This field is required for NONMDSMU.<br/></p>
<p><i>suoappl<br/></i>Is an 8-byte character field that specifies the origin application name.<br/>The application name can be one of the following values:<br/>v An architecturally defined 4-byte value (padded with blanks to 8 bytes) for<br/></p>
<p>MS application programs.<br/>v A 1&#8211;8 character installation-defined name (padded with blanks). Use the<br/></p>
<p>EBCDIC characters 0-9 and A-Z (capitals only).<br/>v A 1&#8211;8 character NetView-reserved name (padded with blanks) that<br/></p>
<p>represents an architecturally defined 4-byte value. NetView-reserved names<br/>and the corresponding values follow:<br/><b>EP_OPS<br/></b></p>
<p>X'23F0F1F6'<br/><b>OPS_MGMT<br/></b></p>
<p>X'23F0F1F7'<br/>Only use OPS_MGMT as <i>suoappl </i>if operations management on the origin<br/>NetView program is defined as a focal point.<br/></p>
<p>This field is required for NONMDSMU.<br/><i>supri<br/></i></p>
<p>Is an 8-byte character field that specifies the MQS priority for incoming<br/>solicited requests or any MDS error messages resulting from any outgoing<br/>MDS-MUs. The MQS priority is used when the MS transport uses the MQS for<br/>processing any solicited MDS-MUs or any MDS error messages.<br/><b>HIGH </b>Processing begins after any NORMAL requests currently in progress<br/></p>
<p>completes, but before queued NORMAL or LOW requests.<br/><b>LOW </b>Processing is preempted by HIGH and NORMAL priority requests.<br/></p>
<p>This is the default for all requests other than synchronous requests.<br/><b>NORMAL<br/></b></p>
<p>Processing preempts a queue of LOW priority requests. This is the<br/>default for synchronous requests.<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>
<p>Chapter 11. Service reference <b>257</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>TEST </b>CNMSMU queues the request based on the command priority of the<br/>receiving task. The command priority can be set using the OVERRIDE<br/>or DEFAULT commands. Refer to the NetView online help.<br/></p>
<p><i>surplcmd<br/></i>Is an 8-byte character field containing the name of the NetView command to<br/>be driven with the reply. The <i>surplcmd </i>field is used only in an MS application<br/>that is sending a REQUEST_WITH_REPLY with the reply being received<br/>asynchronously. Otherwise, it is ignored.<br/>This is an optional field. The default is the registered command for the<br/>invoking application.<br/></p>
<p><i>susupcor<br/></i>Is a varying length character field containing a complete unit of the unit of<br/>work correlator (X'1549') GDS variable. Refer to the SNA library for more<br/>information about defining the correlator.<br/>The <i>susupcor </i>field is not valid for MDSMU. For NONMDSMU, specify either<br/><i>suspcor </i>or <i>sucorrar</i>. If you specify <i>susupcor</i>, the supplied value is used to build<br/>the MDS header. No validity checking is done for a correlator supplied by the<br/>invoker.<br/></p>
<p><i>susynch<br/></i>Is an 8-byte character field that specifies whether the MS application is to<br/>receive the reply synchronously.<br/><b>NO </b>Indicates that the reply is received asynchronously. NO is the default<br/></p>
<p>for the PL/I macro format.<br/><b>NO_BUF<br/></b></p>
<p>Do not suspend the application but buffer replies until the one last is<br/>received. This value is equivalent to the NO value.<br/></p>
<p><b>NO_UNBUF<br/></b>Do not suspend the application and forward replies immediately.<br/></p>
<p><b>YES </b>Indicates that the reply is received synchronously.<br/><b>YES_BUF<br/></b></p>
<p>Suspend the application and buffer its replies. This value is equivalent<br/>to the YES value.<br/></p>
<p>If you do not specify the SYNCH keyword when using the PL/I macro format<br/>for REQUEST_WITH_REPLY, the default value is used. Otherwise, this field is<br/>required for REQUEST_WITH_REPLY.<br/></p>
<p><i>sutimout<br/></i>Is a 4-byte integer field that specifies the number of seconds to wait for a reply<br/>to an outstanding REQUEST_WITH_REPLY.<br/>For a REQUEST_WITH_REPLY that generates multiple replies, the timeout<br/>value applies only to the last reply.<br/>For requests that generate multiple replies, the timeout value applies only to<br/>the last reply.<br/>NetView initializes the default and maximum timeout values for the LU 6.2<br/>transport send services. The initial default and maximum timeout values are<br/>120 seconds and 86400 seconds, respectively. You can change these values with<br/>the DEFAULTS command.<br/>The valid values for <i>sutimout </i>are:<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>1 ... X<br/></b>Where X is the maximum timeout value.<br/></p>
<p><b>0 </b>Indicates the default timeout value.<br/><b>&#8211;1 </b>Indicates the maximum timeout value.<br/>If you do not specify the TIMEOUT keyword when using the PL/I macro<br/>format for REQUEST_WITH_REPLY, the default timeout value is used.<br/>Otherwise, this field is required for REQUEST_WITH_REPLY.<br/></p>
<p><b>Usage Notes:<br/></b>1. For a synchronous REQUEST_WITH_REPLY, control is returned to the<br/></p>
<p>invoking program after the last reply or an error message is received and<br/>placed on the MDSMUQ data queue. Otherwise, control is returned after<br/>CNMSMU successfully queues the request to the MS transport.<br/></p>
<p>2. When the invoking program is suspended because of a synchronous<br/>REQUEST_WITH_REPLY, the NetView task where the program is running is<br/>not suspended. The task still receives and processes messages and commands.<br/></p>
<p>3. For a synchronous REQUEST_WITH_REPLY from a data services task (DST), a<br/>DSRB is marked in-use and the DSRB is not available for other use until the<br/>suspended program is resumed.<br/></p>
<p>4. For MDSMU, all fields within the MDS-MU header must be correct except for<br/>origin NETID and LUNAME. NETID and LUNAME must be left out, not<br/>blank or null, for the service routine to determine and set these fields. If the<br/>correlator is not contained in the data, specify <i>sucorrar</i>.<br/></p>
<p>5. For REPLY_ONLY, REPLY_NOTLAST, REPLY_LAST, and ERROR_MESSAGE,<br/>specify <i>susupcor </i>to return the correlator sent with the request.<br/></p>
<p>6. The MS transport implements a timeout value for the application receiving the<br/>data. If the invocation of CNMSMU specifies a timeout value greater than the<br/>timeout value set by the transport at the receiving node, the sending<br/>application might time out in less than the specified interval.<br/></p>
<p>7. When VTAM is active, you can use CNMSMU to send data to another<br/>application in the same domain.<br/></p>
<p>8. If <i>sudstnet </i>is not the NETID determined by VTAM for the LU specified in<br/><i>sudstlu</i>, the send fails.<br/></p>
<p>9. An MS application or operations management served application cannot send<br/>data to itself within the same NetView program.<br/></p>
<p>10. If you specify both <i>susupcor </i>and <i>sucorrar</i>, <i>susupcor </i>is used.<br/>11. Return code 24 or 28 from DSIPUSH indicates that DSIOLGFP is not defined<br/></p>
<p>correctly in DSICMD.<br/>12. If CNM_BAD_CES is returned:<br/></p>
<p>v Make sure DSI6SNDP is defined correctly in DSICMD.<br/>v If you specify <i>hrrepcmd</i>, make sure it is defined correctly in DSICMD.<br/>v If you specify a synchronous REQUEST_WITH_REPLY, make sure<br/></p>
<p>DSIOSRCP is defined correctly in DSICMD.<br/>v If the sending application is an operations management served application,<br/></p>
<p>make sure DSIOARCP is defined properly in DSICMD.<br/>13. Refer to the <i>IBM Tivoli NetView for z/OS Administration Reference </i>for the correct<br/></p>
<p>definitions of the command processors supplied by the NetView product.<br/>14. For MDSMU, if you omit the NETID subfield of the destination subvector<br/></p>
<p>from the MDS-MU header, VTAM determines the network name used, based<br/>on the LU name in the NAU name subfield of the destination subvector.<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>
<p>Chapter 11. Service reference <b>259</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>15. If you do not specify the destination NETID, and the destination LU name<br/>exists in more than one network, VTAM determines the destination NETID<br/>based on the active configuration.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Requested function was performed.<br/>CNM_BAD_INVOCATION 4 Task is terminating, and a<br/></p>
<p>request-with-reply is being sent.<br/>CNM_NO_STORAGE 24 No storage is available.<br/>CNM_NOT_IN_ASYNC 44 Send MU service is started in an<br/></p>
<p>asynchronous exit.<br/>CNM_BAD_TIMEOUT 56 Time-out value is not valid.<br/>CNM_BAD_LENGTH 88 MDS-MU length is not valid.<br/>CNM_TASK_INACTIVE 220 DSI6DST task is inactive.<br/>CNM_BAD_DATA_TYPE 400 Data type is not valid.<br/>CNM_BAD_DATA 404 DATA missing or is not valid.<br/>CNM_SAME_APPL 408 Application cannot send data to the<br/></p>
<p>same application within the same<br/>NetView program.<br/></p>
<p>CNM_SYNCH_NOT_COMP 412 SYNCH(YES) is not allowed under a<br/>NetView installation exit or a PPT.<br/></p>
<p>CNM_OAPPL_NOT_REG 416 Application is not registered.<br/>CNM_BAD_SAPPL 420 Operations management served<br/></p>
<p>application is not registered.<br/>CNM_BAD_UOW 424 UOW missing or is not valid.<br/>CNM_BAD_RTI 428 R&amp;TI missing or is not valid.<br/>CNM_BAD_OAN 432 OAN missing or is not valid.<br/>CNM_BAD_DAN 436 DAN is not valid.<br/>CNM_BAD_OAPPL 440 Origin application name is not valid.<br/>CNM_BAD_DNETID 444 Destination network ID missing or is<br/></p>
<p>not valid.<br/>CNM_BAD_DLU 448 Destination LU name missing or is not<br/></p>
<p>valid.<br/>CNM_BAD_DAPPL 452 Destination application name missing<br/></p>
<p>or is not valid.<br/>CNM_BAD_OII 456 OII in R&amp;TI does not match TVBOPID.<br/>CNM_BAD_REPLY 460 Reply is not valid.<br/>CNM_BAD_MUTYPE 464 Bad MUTYPE given.<br/>CNM_BAD_SYNCH 468 Bad SYNCH option.<br/>CNM_BUSY 472 Too many concurrent requests.<br/>CNM_SYNCH_CMD_MISSING 508 SYNCH(YES) is specified but<br/></p>
<p>DSIOSRCP is not defined or is not<br/>defined correctly in DSICMD.<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Return Code Name Value Description<br/></b>CNM_SAME_OMAPPL 548 Operations management served<br/></p>
<p>application cannot send data to the<br/>same operations management served<br/>application within the same NetView.<br/></p>
<p>CNM_REQ_CANCELED 552 Synchronous request canceled by user.<br/>CNM_TASK_NO_AUTH 556 Task does not have authorization to run<br/></p>
<p>the registered command associated with<br/>the origin application or OAN.<br/></p>
<p>CNM_BAD_OM_MDSEM 560 Operations management served<br/>application is not allowed to send MDS<br/>error message. The routing report is<br/>sent instead.<br/></p>
<p>CNM_SNACR_MISSING 588 SNACR (X'1532') is missing from MDS<br/>error message.<br/></p>
<p>CNM_NETID_UNINIT 596 NETID is not initialized.<br/>CNM_BAD_MQS + X 1000 + X X is the return code from DSIMQS.<br/>CNM_BAD_PUSH + X 4000 + X X is the return code from DSIPUSH.<br/>CNM_BAD_CES + Y 9000 + Y Reply command is not valid. Y is the<br/></p>
<p>return code from DSICES.<br/></p>
<p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.<br/></p>
<p><b>CNMSUBS (CNMSUBSYM): Substitute System Symbolics<br/></b>You can use the CNMSUBS service routine to substitute any MVS or user-defined<br/>system symbolics found in the source string for their system values and place the<br/>resulting string in the target string. The &amp;DOMAIN symbolic supplied by the<br/>NetView product is also included in the substitution process.<br/></p>
<p>The CNMSUBS routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMSUBS(<i>hlbptr,sssource,sstarget,sslen,sstype</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMSUBSYM SOURCE(<i>sssource</i>) TARGET(<i>sstarget</i>) LENG(<i>sslen</i>) COPYTYPE(<i>sstype</i>)<br/></p>
<p><b>C INVOCATION</b>:<br/>void Cnmsubs(void *<i>sssource</i>, void *<i>sstarget</i>, int *<i>sslen</i>, char *<i>sstype</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>hlbptr<br/></i></p>
<p>Is a 4-byte pointer field containing the address of the HLB control block.<br/><i>sslen<br/></i></p>
<p>Is a 4-byte integer field containing the length of both <i>sssource </i>and <i>sstarget<br/></i>which must be the same length.<br/>If the value specified by <i>sslen </i>is less than the length of the data to be returned,<br/>the truncated data is returned and a return code of CNM_DATA_TRUNC is<br/>generated. The length of the returned data is stored in HLBLENG(<i>Hlbleng</i>).<br/></p>
<p><b>CNMSMU (CNMSENDMU)<br/></b></p>
<p>Chapter 11. Service reference <b>261</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>If the value specified by <i>sslen </i>is equal to or greater than the length of the data<br/>to be returned and HLBRC(Hlbrc) = CNM_GOOD, the length of the returned<br/>data is stored in HLBLENG(<i>Hlbleng</i>).<br/>If the value specified is greater than the length of the receiving data area<br/>(<i>sstarget</i>), a storage overlay can occur.<br/></p>
<p><i>sssource<br/></i>Is a 4-byte pointer field containing the address of the source character string<br/>which has MVS system symbolics embedded in it or a single MVS system<br/>symbolic. Substitution is always performed on the &amp;DOMAIN symbolic, unless<br/>substitution was disabled when NetView was started. For MVS and<br/>user-defined system symbolics, substitution is not performed if substitution<br/>was disabled when NetView was started, or you have not defined an MVS<br/>system symbolic on your MVS system.<br/></p>
<p><i>sstarget<br/></i>Is a 4-byte pointer field containing the address of the target character string<br/>which contains the source string with the MVS system symbolic values<br/>substituted upon completion of this service.<br/></p>
<p><i>sstype<br/></i>Is an 8-byte character field specifying whether the source and target fields are<br/>fixed or varying fields. The following are the valid types:<br/><b>FIXTOFIX<br/></b></p>
<p>Both <i>sssource </i>and <i>sstarget </i>are fixed length fields.<br/><b>FIXTOVAR<br/></b></p>
<p><i>sssource </i>is a fixed length field and <i>sstarget </i>is a varying length field.<br/><b>VARTOFIX<br/></b></p>
<p><i>sssource </i>is a varying length field and <i>sstarget </i>is a fixed length field.<br/><b>VARTOVAR<br/></b></p>
<p>Both <i>sssource </i>and <i>sstarget </i>are varying length fields.<br/></p>
<p><b>Usage Notes:<br/></b>1. The source and target fields cannot overlap.<br/>2. The length field of varying length fields is not set or altered by CNMSUBS.<br/>3. When using CNMSUBS with C and <i>sstype's </i>of FIXTOFIX, FIXTOVAR, or<br/></p>
<p>VARTOFIX, pass CNMSUBS the address of a pointer to your fixed length field.<br/>You can do this by coding a variable as a pointer to a string, and then passing<br/>CNMSUBS the address of that pointer.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Everything is OK.<br/>CNM_DATA_TRUNC 40 <i>sslen </i>was too small. <i>sstarget </i>data truncated.<br/>CNM_BAD_LENGTH 88 <i>sslen </i>less than (&lt;) 0.<br/>CNM_BAD_ADDR 160 The storage pointed to by <i>ssource </i>or <i>sstarget </i>is not<br/></p>
<p>addressable, or the storage pointed to by <i>sstarget<br/></i>is protected (not writable).<br/></p>
<p>CNM_BAD_SSTYPE 320 Incorrect <i>sstype</i>.<br/>CNM_BAD_ESTAE 15000 Nonzero return code from ESTAE macro.<br/></p>
<p><b>CNMSUBS (CNMSUBSYM)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Refer to <i>IBM Tivoli NetView for z/OS Programming: Assembler </i>for more information.<br/></p>
<p><b>CNMVARS (CNMVARPOOL): Set or Retrieve Variables<br/></b>A variable pool is a collection of named variables whose values can be set or<br/>retrieved by NetView command procedures, assembler command processors, and<br/>HLL installation exit routines. You can access the following types of variable pools<br/>from HLL command processors or HLL installation exit routines:<br/>v The HLL command processor or installation exit routine&#8217;s own pool<br/>v The variable pool of the calling command procedure if the current HLL<br/></p>
<p>command processor or installation exit routine was called from a command<br/>procedure<br/></p>
<p>v The task global pool shared by all command procedures and HLL installation<br/>exit routines running under a NetView task<br/></p>
<p>v The common global pool shared by all command procedures and HLL<br/>installation exit routines running in a NetView address space.<br/></p>
<p>The CNMVARS routine syntax follows:<br/></p>
<p><b>PL/I CALL FORMAT</b>:<br/>CALL CNMVARS(<i>hlbptr,cvfunc,cvdata,cvdatlen,cvname,cvpool</i>)<br/></p>
<p><b>PL/I MACRO FORMAT</b>:<br/>CNMVARPOOL FUNC(<i>cvfunc</i>) NAME(<i>cvname</i>) POOL(<i>cvpool</i>)<br/>DATA(<i>cvdata</i>) LENG(<i>cvdatlen</i>)<br/></p>
<p><b>C INVOCATION</b>:<br/>void Cnmvars(char *<i>cvfunc</i>, void *<i>cvdata</i>, int <i>cvdatlen</i>,<br/>void *<i>cvname</i>, char *<i>cvpool</i>)<br/></p>
<p><b><i>Where:<br/></i></b><i>cvdata<br/></i></p>
<p>Is a varying length character field containing the value of the named variable.<br/>This field is required for PUT and GET, but not used for DCL.<br/></p>
<p><i>cvdatlen<br/></i>Is a 4-byte integer field containing the length of <i>cvdata</i>. This is the maximum<br/>length of the area provided to receive the returned data. You provide <i>cvdatlen</i>.<br/>This field is required only for GET.<br/>If the value specified by <i>cvdatlen </i>is less than the length of the data to be<br/>returned, the truncated data is returned in <i>cvdata </i>and a return code of<br/>CNM_DATA_TRUNC is generated. The full length of the data that was<br/>truncated is stored in HLBLENG (<i>Hlbleng</i>).<br/>If the value specified by <i>cvdatlen </i>is equal to or greater than the length of the<br/>data to be returned, and HLBRC (<i>Hlbrc</i>) = CNM_GOOD, the length of the<br/>returned data is stored in HLBLENG (<i>Hlbleng</i>).<br/>If the value specified by <i>cvdatlen </i>is greater than the length of the receiving data<br/>buffer (<i>cvdata</i>), a storage overlay can occur.<br/></p>
<p><i>cvfunc<br/></i>Is an 8-byte character field that specifies the function to be performed. This<br/>field is required for all CNMVARS calls.<br/></p>
<p><b>CNMVARS (CNMVARPOOL)<br/></b></p>
<p>Chapter 11. Service reference <b>263</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>DCL </b>Declares the local variable to belong to one of the global pools, or<br/>resets it to the local pool. (You cannot declare a variable that belongs to<br/>the caller&#8217;s pool.)<br/></p>
<p><b>GET </b>Gets the variable value<br/><b>PUT </b>Sets the variable value<br/></p>
<p><i>cvname<br/></i>Is a varying length character field that specifies the name of the variable. This<br/>field is required for all functions.<br/>Valid characters are A&#8211;Z, 0&#8211;9, @, #, $, +, ., !, ?, and underscore. The first<br/>character of <i>cvname </i>cannot be a number or a period.<br/></p>
<p><i>cvpool<br/></i>Is an 8-byte character field that specifies the variable pool. This field is<br/>required for all functions.<br/><b>CALLER<br/></b></p>
<p>The local pool of the calling command procedure or HLL installation<br/>exit routine (if one exists).<br/></p>
<p><b>CGLOBAL<br/></b>Common global<br/></p>
<p><b>LOCAL<br/></b>The local pool of the current HLL command processor or installation<br/>exit routine<br/></p>
<p><b>TGLOBAL<br/></b>Task global<br/></p>
<p><i>hlbptr<br/></i>Is a 4-byte pointer field containing the address of the HLB control block.<br/></p>
<p><b>Usage Notes:<br/></b>1. You can access all existing NetView command list language and REXX local or<br/></p>
<p>global variables (both task and common) using CNMVARS. In the NetView<br/>command list language, local variable names are restricted to a length of 1&#8211;11<br/>characters. All other variable names can be 1-250 characters.<br/></p>
<p>2. Although the length limits for task and common global variable names and<br/>values are 250 and 31000 bytes, respectively, the Save/Restore database<br/>(managed by the DSISVRT task) limits are lower. Refer to the GLOBALV<br/>SAVE command for more detailed information. For double-byte character sets<br/>(DBCS), the maximum number of double-byte characters between the shift-out<br/>(X'0E') and shift-in (X'0F') control characters is 15499.<br/></p>
<p>3. If you are accessing REXX or HLL global variables from the NetView<br/>command list language, the REXX and HLL variable names must adhere to<br/>NetView command list language rules. The character set allowed for variable<br/>names in NetView command list language is also smaller than in REXX and<br/>HLL. The valid characters for REXX variable names are the same as HLL; see<br/>the operand <i>cvname </i>previously mentioned.<br/></p>
<p>4. The C program using CNMVARS must be called by a command list language,<br/>REXX, or HLL command procedure to PUT to or GET from a CALLER pool.<br/>Otherwise, a return code of CNM_BAD_POOL is issued.<br/></p>
<p>5. You do not have to initially put a value into the calling HLL command<br/>processor or installation exit routine&#8217;s LOCAL pool before issuing a PUT in<br/>the called HLL command processor or installation exit routine CALLER pool.<br/>When control is returned to the calling HLL command processor or<br/></p>
<p><b>CNMVARS (CNMVARPOOL)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>installation exit routine, you can issue a GET for the same variable name in<br/>the LOCAL pool to retrieve the value set in the called HLL command<br/>processor or installation exit routine&#8217;s CALLER pool.<br/></p>
<p>6. Any PUTs in an HLL command processor or installation exit routine&#8217;s<br/>CALLER pool change the value of the same variable name in the calling<br/>command procedure or HLL installation exit routine&#8217;s LOCAL pool.<br/></p>
<p>7. You can set three different values (<i>cvdata</i>) in the same variable name (<i>cvname</i>)<br/>if you specify different pools (<i>cvpool</i>). For example:<br/>CNMVARPOOL FUNC(&#8217;PUT&#8217;) NAME(x) POOL(&#8217;LOCAL&#8217;) DATA(&#8217;cvdata1&#8217;);<br/>CNMVARPOOL FUNC(&#8217;PUT&#8217;) NAME(x) POOL(&#8217;CGLOBAL&#8217;) DATA(&#8217;cvdata2&#8217;);<br/>CNMVARPOOL FUNC(&#8217;PUT&#8217;) NAME(x) POOL(&#8217;TGLOBAL&#8217;) DATA(&#8217;cvdata3&#8217;);<br/></p>
<p>8. The calling HLL command processor or installation exit routine&#8217;s LOCAL pool<br/>is the same as the called HLL command processor or installation exit routine&#8217;s<br/>CALLER pool.<br/></p>
<p>9. The DCL operand can be useful when an HLL command processor invokes<br/>VIEW. Ensure that the variables are properly declared to the corresponding<br/>common or task global pools. Otherwise, the variables used can be from the<br/>local pool and the full-screen panel is not automatically updated.<br/></p>
<p>10. Declare task and common global variables to their respective pools before<br/>invoking VIEW from an HLL command processor. Otherwise, VIEW does not<br/>pick up the values. DCL is not necessary for local variables.<br/></p>
<p><b>Return Codes:<br/>Return Code Name Value Description<br/></b>CNM_GOOD 0 Everything is OK.<br/>CNM_NOT_FOUND 20 <i>cvname </i>not found or value of <i>cvname </i>is null.<br/>CNM_DATA_TRUNC 40 <i>cvdatlen </i>was too small. Data truncated.<br/>CNM_BAD_FUNC 52 Incorrect <i>cvfunc</i>.<br/>CNM_BAD_LENGTH 88 <i>cvdatlen </i>less than (&lt;) 0 or <i>cvdata </i>greater than<br/></p>
<p>(&gt;) 31000.<br/>CNM_BAD_NAME 108 Incorrect <i>cvname</i>.<br/>CNM_BAD_POOL 156 Incorrect <i>cvpool</i>.<br/>CNM_BAD_ADDR 160 The storage pointed to by <i>cvdata </i>is not<br/></p>
<p>addressable.<br/>CNM_BAD_CDS + X 14000 + X Nonzero return code, X. See values for X<br/></p>
<p>below.<br/></p>
<p><b>Values for X:<br/>Value for X Description<br/></b></p>
<p>4 Incorrect variable name.<br/>8 Variable name already defined in dictionary.<br/></p>
<p>12 Insufficient storage.<br/>20 Value length limit was exceeded.<br/>28 No command procedure related to current action.<br/>32 Data was truncated.<br/></p>
<p>v <b>Example 1: Declaring Variables to the Task or Common Global Pool<br/></b>REXX or NetView command list language has declared variables to the task or<br/>common global pool and values have been assigned to these variables. These<br/></p>
<p><b>CNMVARS (CNMVARPOOL)<br/></b></p>
<p>Chapter 11. Service reference <b>265</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>values need to be displayed on a full-screen panel from an HLL command<br/>processor or installation exit routine. Before invoking VIEW, code in the HLL<br/>command processor or installation exit routine:<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;CGLOBAL&#8217;)<br/></p>
<p>or<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;TGLOBAL&#8217;)<br/></p>
<p>v <b>Example 2: Changing the Value of a Variable<br/></b>REXX or NetView command list language has declared variables to the task or<br/>common global pool and values have been assigned to these variables. These<br/>values must be changed within an HLL command processor or installation exit<br/>routine and then displayed on a full-screen panel. Before invoking VIEW, code<br/>in the HLL command processor or installation exit routine:<br/>CNMVARPOOL FUNC(&#8217;PUT&#8217;) NAME(cvname) POOL(&#8217;CGLOBAL&#8217;) DATA(cvdata)<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;CGLOBAL&#8217;)<br/></p>
<p>or<br/>CNMVARPOOL FUNC(&#8217;PUT&#8217;) NAME(cvname) POOL(&#8217;TGLOBAL&#8217;) DATA(cvdata)<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;TGLOBAL&#8217;)<br/></p>
<p><b>Note: </b>The DCL can precede the PUT.<br/>v <b>Example 3: Setting Values for Task and Common Variables<br/></b></p>
<p>An HLL command processor or installation exit routine has set values for either<br/>task or common variables. Before invoking VIEW, code in the HLL command<br/>processor or installation exit routine:<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;CGLOBAL&#8217;)<br/></p>
<p>or<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;TGLOBAL&#8217;)<br/></p>
<p><b>Note: </b>If only a DCL is done (with no PUT), the VIEW panel is blank for that<br/>variable.<br/></p>
<p>v <b>Example 4: Declaring a Variable to the Local Pool<br/></b>You might need to declare (DCL) a variable back to the local pool. Assume you<br/>have the same variable name in both the local and common global pool. If you<br/>have just started VIEW, the variable is declared to the common global pool. If<br/>you want to change the value of the variable in the local pool, issue:<br/>CNMVARPOOL FUNC(&#8217;DCL&#8217;) NAME(cvname) POOL(&#8217;LOCAL&#8217;)<br/></p>
<p><b>CNMVARS (CNMVARPOOL)<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Part 6. Appendixes<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Appendix A. PL/I Control Blocks and Include Files<br/></b>Table 18 describes the PL/I control blocks and include files needed to write<br/>command processors and installation exits in PL/I. The files are located in the<br/>SCNMMAC1 data set.<br/><i>Table 18. List of PL/I control blocks and include files<br/><b></b></i><b>Include File Description<br/></b>DSIPLI include file This file includes all of the external HLL control blocks and include<br/></p>
<p>files needed to run PL/I programs in the NetView environment.<br/>DSIPCONS control<br/>block<br/></p>
<p>This file contains the definitions for constants that are helpful when<br/>coding HLL modules in PL/I.<br/></p>
<p>DSIPHLB control<br/>block<br/></p>
<p>This file contains a PL/I mapping of the NetView HLL control<br/>block (HLB). The HLB is built during command processor<br/>initialization and exists for the lifetime of the command processor.<br/></p>
<p>DSIPORIG control<br/>block<br/></p>
<p>This file defines the mapping of the origin block of the request that<br/>caused the current procedure to run.<br/></p>
<p>DSIPHLLS control<br/>block<br/></p>
<p>This file defines entry points for HLL service routines for PL/I.<br/></p>
<p>DSIPCNM control<br/>block<br/></p>
<p>This file defines the HLL return codes for PL/I.<br/></p>
<p>DSIPPRM control<br/>block<br/></p>
<p>This file defines the NetView Bridge parameter control block to<br/>PL/I HLL service routines.<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>PL/I Control Blocks and Include Files<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Appendix B. PL/I samples<br/></b>This appendix contains a table of the PL/I samples that are shipped with the<br/>NetView program in the CNMSAMP data set. When a data set name is referred to<br/>in this appendix, two names are given, for example PTMPPLT (CNMS4200). The<br/>first name is the alias name, and the name in parentheses is in the NetView<br/>samples library. You can use either name to access the samples. CNMCMD has<br/>definitions for the alias names to allow those names to be entered as commands.<br/></p>
<p>To enter the member names as commands do the following tasks:<br/>1. Compile and link-edit the samples using the alias name.<br/>2. Delete the asterisk (*) in column 1 of the appropriate CMDDEF statement in<br/></p>
<p>CNMCMD to run the alias name as a command. No entries are needed in<br/>CNMCMD for installation exits.<br/></p>
<p>3. Recycle NetView for the CNMCMD changes to go into effect.<br/></p>
<p><b>Note:<br/></b>1. Refer to the prologues of the samples for information about how certain<br/></p>
<p>samples are related and special cases for installation exit routines.<br/>2. Each alias name for PL/I begins with the letter P.<br/>3. In PL/I the alias name is the same as the procedure name, which is limited to 7<br/></p>
<p>characters.<br/></p>
<p>This appendix also contains a description of each sample, and coded samples of an<br/>installation exit routine and two command processors.<br/></p>
<p><b>PL/I samples table<br/></b>Table 19 lists the PL/I samples that are shipped with the NetView program. The<br/>table contains the function, the alias name, and the name of the member in<br/>NETVIEW.V6R2M1.CNMSAMP.<br/><i>Table 19. PL/I Samples Shipped with the NetView Program<br/><b></b></i><b>Sample Function PL/I Alias Sample<br/></b></p>
<p><b>CNMSAMP<br/></b>Template for commands and installation exit<br/>routines<br/></p>
<p>PTMPPLT CNMS4200<br/></p>
<p>Sample DSIEX03 to set a global variable PEXIT3 CNMS4210<br/>Uses CNMSMSG to send data PSNDDAT CNMS4211<br/>Uses WAIT FOR DATA PWATDAT CNMS4212<br/>Sample DSIEX02A changes a WTO to an MLWTO PEXIT2A CNMS4213<br/>Uses CNMCNMI to forward RUs to a PU PCNMI CNMS4214<br/>Uses CNMKIO for I/O to VSAM PKEYIO CNMS4215<br/>HLL command using CNMSCOP for command<br/>authorization checking<br/></p>
<p>PSCOPCK CNMS4216<br/></p>
<p>Display full screen VIEW panel PFLVIEW CNMS4217<br/>Activates LU and uses TRAP and WAIT to<br/>determine if activation is successful<br/></p>
<p>PACTLU CNMS4218<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><i>Table 19. PL/I Samples Shipped with the NetView Program (continued)<br/><b></b></i><b>Sample Function PL/I Alias Sample<br/></b></p>
<p><b>CNMSAMP<br/></b>Uses CNMSMSG to log text to a sequential log PSEQLOG CNMS4219<br/>Sets a common global variable for the USERVSAM<br/>DST<br/></p>
<p>PXITDI CNMS4220<br/></p>
<p>Primes VSAM empty data set for USERVSAM DST PXITVN CNMS4221<br/>Sends a request to USERVSAM DST PSNDDST CNMS4222<br/>Processes VSAM requests under USERVSAM DST PDOVSAM CNMS4223<br/>Primes VSAM empty data set for PKEYIO PPRIME CNMS4224<br/>Sends a software alert to an application over the<br/>high performance transport<br/></p>
<p>PHSNDMU CNMS4226<br/></p>
<p>Uses CNMQAPI to access a RODM PRODMCON CNMS4230<br/>Sends an MSU directly to the automation table for<br/>evaluation<br/></p>
<p>PAUTOTB CNMS4231<br/></p>
<p>Registers or deregisters an application as an MS<br/>application or an operations management served<br/>application<br/></p>
<p>PREGISTR CNMS4232<br/></p>
<p>Sends a software alert to ALERT_NETOP from an<br/>MS application<br/></p>
<p>PSENDMU CNMS4233<br/></p>
<p>Registers an application with the high performance<br/>transport<br/></p>
<p>PHREGSTR CNMS4236<br/></p>
<p>Uses CNMPMDB to process MDB PPRSMDB CNMS4239<br/>Uses the PIPE command to activate an LU, wait, and<br/>trap the output messages<br/></p>
<p>PACTPIP CNMS4305<br/></p>
<p><b>PTMPPLT (CNMS4200)<br/></b>This sample is a template for commands and installation exit routines in PL/I.<br/></p>
<p>It appears in Chapter 7, &#8220;PL/I high-level language services,&#8221; on page 59.<br/></p>
<p><b>PEXIT3 (CNMS4210)<br/></b>This is a sample DSIEX03 that sets a task global variable. This global variable<br/>contains the value of the last time that a command other than PSNDDAT was<br/>entered under an operator station task (OST). PWATDAT and PSNDDAT are used<br/>to interrogate this value. The HLL service routines used in this sample are<br/>CNMINFC (CNMINFOC) and CNMVARS (CNMVARPOOL).<br/></p>
<p><b>PSNDDAT (CNMS4211)<br/></b>This sample uses CNMSMSG to send data. The sample is part of an example of<br/>sending messages containing a request, waiting for the response, and parsing the<br/>results.<br/></p>
<p>The example finds the last time that a command was entered on a given OST. A<br/>task global variable is set by PEXIT3 every time a command is entered on an OST.<br/>PWATDAT uses CNMSMSG to issue a PSNDDAT on the task in question.<br/>PWATDAT then goes into a wait state. PSNDDAT retrieves the value of the global<br/></p>
<p><b>PL/I Samples<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>variable and uses CNMSMSG to send the data back to the task that issued the<br/>PWATDAT. PWATDAT breaks out of the wait state and parses and displays the<br/>data.<br/></p>
<p>The HLL service routines used in this sample are CNMVARS (CNMVARPOOL),<br/>CNMSMSG (CNMSENDMSG), and CNMINFC (CNMINFOC).<br/></p>
<p><b>PWATDAT (CNMS4212)<br/></b>This sample uses the WAIT FOR DATA request. The sample is part of an example<br/>of sending messages containing a request, waiting on the response, and parsing the<br/>results.<br/></p>
<p>The example finds the last time that a command was entered on a given OST. A<br/>task global variable is set by PEXIT3 every time a command is entered on an OST.<br/>PWATDAT uses CNMSMSG to issue a PSNDDAT on the task in question.<br/>PWATDAT then goes into a wait state. PSNDDAT retrieves the value of the global<br/>variable and uses CNMSMSG to send the data back to the task that issued the<br/>PWATDAT. PWATDAT breaks out of the wait state and parses and displays the<br/>data.<br/></p>
<p>The HLL service routines used in this sample are CNMSMSG (CNMSENDMSG),<br/>CNMSCAN (CNMSSCAN), CNMCMD (CNMCOMMAND), and CNMGETD<br/>(CNMGETDATA).<br/></p>
<p><b>PEXIT2A (CNMS4213)<br/></b>This sample exit converts a write-to-operator (WTO) to a multiline<br/>write-to-operator (MLWTO) by adding two lines to the single-line WTOs that drive<br/>the exit. The HLL service routines used in this sample are CNMGETD<br/>(CNMGETDATA) and CNMALTD (CNMALTDATA).<br/></p>
<p><b>PCNMI (CNMS4214)<br/></b>This sample uses CNMCNMI to send FORWARD RUs to a PU requesting that the<br/>product set ID be returned. Any data returned is sent as a message to the operator.<br/>The prolog of the sample contains instructions for setup.<br/></p>
<p>The NetView program provides the CNMCNMI service routine for use in<br/>communicating with devices in the network through the communications network<br/>management interface (CNMI). You can access any data that is returned using the<br/>CNMGETD service routine to retrieve records from the CNMI solicited data queue<br/>(CNMIQ).<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMCNMI (CNMI), CNMGETD (CNMGETDATA), and CNMSMSG<br/>(CNMSENDMSG).<br/></p>
<p><b>PKEYIO (CNMS4215)<br/></b>This sample illustrates how to code a NetView HLL command processor that<br/>allows input/output (I/O) to a VSAM file through the CNMKIO service routine.<br/>The command processor must run on a data services task (DST). To run this<br/>command, use the EXCMD command or the CNMSMSG service routine (using <i>type<br/></i>set to COMMAND). The prologue of the sample explains how to set up the<br/>command processor.<br/></p>
<p><b>PL/I Samples<br/></b></p>
<p>Appendix B. PL/I samples <b>273</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>The HLL service routines used in this sample are CNMKIO (CNMKEYIO) and<br/>CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PSCOPCK (CNMS4216)<br/></b>This sample illustrates the command authorization checking capabilities provided<br/>by the NetView program. It authorizes keywords and values using the PSCOPCK<br/>command. Set up the following elements:<br/>v Operator ID<br/>v Operator classes that can access the command<br/>v Operator profile<br/></p>
<p>Refer to the prologue of the sample for more information. This command yields a<br/>message if the operator is not authorized to use the keyword and value specified<br/>when invoking the command.<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMSCOP (CNMSCOPECK), and CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PFLVIEW (CNMS4217)<br/></b>This sample illustrates the use of the full-screen VIEW command processor.<br/></p>
<p>The HLL service routines used in this sample are CNMCMD (CNMCOMMAND)<br/>and CNMVARS (CNMVARPOOL).<br/></p>
<p><b>PACTLU (CNMS4218)<br/></b>This sample illustrates how to issue a VTAM command to activate a logical unit<br/>(LU), trap the VTAM messages that result, and respond depending on the<br/>messages received.<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMCMD (CNMCOMMAND), CNMGETD (CNMGETDATA), and CNMSMSG<br/>(CNMSENDMSG).<br/></p>
<p><b>PSEQLOG (CNMS4219)<br/></b>This sample uses CNMSMSG to log text to a sequential log. The prolog of the<br/>sample contains instructions for setup.<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMINFC (CNMINFOC), and CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PXITDI (CNMS4220)<br/></b>This sample illustrates the DST initialization exit that is used by the USERVSAM<br/>DST. The HLL service routines used in this sample are CNMVARS<br/>(CNMVARPOOL) and CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PXITVN (CNMS4221)<br/></b>This sample primes a VSAM empty data set for the USERVSAM DST.<br/></p>
<p><b>PL/I Samples<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>PSNDDST (CNMS4222)<br/></b>This sample sends a PUT or GET request to the sample HLL data services<br/>command processor PDOVSAM to store and retrieve a given value for a specified<br/>key (key and value limited to 11 characters in length). The sample also allows a<br/>specified NetView program command list language variable (defined by the caller)<br/>to be set to the retrieved value.<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMSMSG (CNMSENDMSG), CNMVARS (CNMVARPOOL), CNMGETD<br/>(CNMGETDATA), and CNMCMD (CNMCOMMAND).<br/></p>
<p><b>PDOVSAM (CNMS4223)<br/></b>This sample is an HLL data services command processor that runs under the<br/>sample data services task (task ID USERVSAM). It processes PUT or GET requests<br/>sent by the PSNDDST sample, and writes or reads an 11-character value associated<br/>with an 11-character key to the sample DST's VSAM data set. The prologue of<br/>PDOVSAM contains instructions on installing the sample USERVSAM data<br/>services task.<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMSMSG (CNMSENDMSG), and CNMKIO (CNMKEYIO).<br/></p>
<p><b>PPRIME (CNMS4224)<br/></b>This sample primes a VSAM empty data set for PKEYIO.<br/></p>
<p><b>PHSNDMU (CNMS4226)<br/></b>This sample sends a software alert to an application over the high performance<br/>transport.<br/></p>
<p>The HLL service routines used are CNMHSMU (CNMHSENDMU) and<br/>CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PRODMCON (CNMS4230)<br/></b>This sample invokes CNMQAPI which enables the user to access a RODM under<br/>the control of the NetView program. The coded example shows a RODM<br/>CONNECT function.<br/></p>
<p>The HLL service routines used in this sample are CNMSMSG (CNMSENDMSG)<br/>and CNMQAPI (CNMOPREP).<br/></p>
<p><b>PAUTOTB (CNMS4231)<br/></b>This sample sends an MSU directly to the automation table for evaluation. This<br/>sample provides a method of testing automation table statements without sending<br/>an alert through the hardware monitor.<br/></p>
<p>The HLL service routines used in this sample are CNMAUTO (CNMAUTOTAB),<br/>CNMSMSG (CNMSENDMSG), and CNMSCAN (CNMSSCAN).<br/></p>
<p><b>PL/I Samples<br/></b></p>
<p>Appendix B. PL/I samples <b>275</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>PREGSTR (CNMS4232)<br/></b>This sample registers or deregisters an application as an MS application or an<br/>operations management served application.<br/></p>
<p>Provide the following information:<br/>v Application name<br/>v Command name<br/>v Logmode<br/>v Replace option<br/>v Registration type<br/></p>
<p>Refer to the prologue of the sample for more information. This command sends a<br/>message to the invoking operator that reports the return code from the registration<br/>or deregistration.<br/></p>
<p>The HLL service routines used in this sample are CNMRGS (CNMREGIST),<br/>CNMSMSG (CNMSENDMSG), and CNMSCAN (CNMSSCAN).<br/></p>
<p><b>PSENDMU (CNMS4233)<br/></b>This sample sends a software alert to ALERT_NETOP from an MS application.<br/></p>
<p>The HLL service routines used in this sample are CNMSMU (CNMSENDMU) and<br/>CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PHREGSTR (CNMS4236)<br/></b>This sample registers an application with the high performance transport.<br/></p>
<p>Provide the following information:<br/>v Application name<br/>v Command name<br/>v Replace option<br/>v Registration type<br/>v Focal point category<br/>v Focal point option<br/>v Notify option<br/></p>
<p>Refer to the prologue of the sample for more information. This command sends a<br/>message to the invoking operator that reports the return code from the registration<br/>or deregistration.<br/></p>
<p>The HLL service routines used in this sample are CNMHRGS (CNMHREGIST),<br/>CNMSMSG (CNMSENDMSG), and CNMSCAN (CNMSSCAN).<br/></p>
<p><b>PPRSMDB (CNMS4239)<br/></b>This HLL sample sends a Message Data Block (MDB) to the NetView program for<br/>processing. The MDB is a designed structure for message data. The MDB structure<br/>is mapped by the MVS control block IEAVM105.<br/></p>
<p><b>PL/I Samples<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>The HLL services used in this sample are CNMPMDB (CNMPRSMDB) and<br/>CNMSMSG (CNMSENDMSG).<br/></p>
<p><b>PACTPIP (CNMS4305)<br/></b>This sample illustrates how to use the PIPE command to issue a VTAM command.<br/>The VTAM command activates a logical unit (LU), traps the resulting VTAM<br/>messages, and responds depending on the messages received.<br/></p>
<p>The HLL service routines used in this sample are CNMSCAN (CNMSSCAN),<br/>CNMVARS (CNMVARPOOL), CNMCMD (CNMCOMMAND), and CNMSMSG<br/>(CNMSENDMSG).<br/></p>
<p><b>PL/I Samples<br/></b></p>
<p>Appendix B. PL/I samples <b>277</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Appendix C. C language control blocks and include files<br/></b>Table 20 describes the C control blocks and the include files needed to write<br/>command processors and installation exits in the C language. The files are located<br/>in the SCNMMAC1 data set.<br/><i>Table 20. List of C control blocks and include files<br/><b></b></i><b>Include File Description<br/></b>DSIC include file This file is required and must be included by all HLL programs<br/></p>
<p>written in C. DSIC includes all of the external HLL control blocks<br/>and include files needed to run C programs in the NetView<br/>environment.<br/></p>
<p>DSICCONS control<br/>block<br/></p>
<p>This file contains the definitions for constants that are helpful when<br/>coding HLL modules in C.<br/></p>
<p>DSICVARC structure<br/>type<br/></p>
<p>This structure type represents varying length character strings for<br/>use in NetView HLL service routine invocations.<br/></p>
<p>DSICHLB control<br/>block<br/></p>
<p>This file contains a C mapping of the NetView HLL control block<br/>(HLB). The HLB is built during command processor initialization<br/>and exists for the lifetime of the command processor.<br/></p>
<p>DSICORIG control<br/>block<br/></p>
<p>This file maps the origin block of the request that initiated the<br/>current procedure.<br/></p>
<p>DSICPRM control<br/>block<br/></p>
<p>This file defines the NetView Bridge parameter control block for C.<br/></p>
<p>DSICCALL control<br/>block<br/></p>
<p>This file defines the service routines for C.<br/></p>
<p>DSICCNM control<br/>block<br/></p>
<p>This file defines the HLL return codes for C.<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>C Control Blocks and Include Files<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Appendix D. C samples<br/></b>This appendix contains a table of the C samples that are shipped with the NetView<br/>program in the CNMSAMP data set. When a data set name is referred to in this<br/>appendix, two names are given, for example CTMPPLT (CNMS4201). The first<br/>name is the alias name, and the name in parentheses is in the NetView samples<br/>library. You can use either name to access the samples. CNMCMD has definitions<br/>for the alias names to enable those names to be entered as commands.<br/></p>
<p>To enter the member names as commands, perform the following steps:<br/>1. Compile and link-edit the samples using the alias name.<br/>2. Delete the * in column 1 of the appropriate CMDDEF statement in CNMCMD<br/></p>
<p>to run the alias name as a command. No entries are needed in CNMCMD for<br/>installation exits.<br/></p>
<p>3. Recycle the NetView program for the CNMCMD changes to take effect.<br/></p>
<p><b>Note:<br/></b>1. Refer to the prolog of the samples for information about how certain samples<br/></p>
<p>are related and special cases for installation exit routines.<br/>2. Each alias name for C begins with the letter C.<br/></p>
<p>This appendix also contains a description of each sample, and coded samples of an<br/>installation exit routine and two command processors.<br/></p>
<p><b>C language samples table<br/></b>The following table refers to the C language samples that are shipped with the<br/>NetView program. The table contains the function, the alias name, and the name of<br/>the member in NETVIEW.V6R2M1.CNMSAMP.<br/></p>
<p><i>Table 21. C Samples Shipped with the NetView Program<br/><b></b></i><b>Sample Function C Alias Sample CNMSAMP<br/></b>Template for commands and installation exit routines CTMPPLT CNMS4201<br/>Sample DSIEX03 to set a global variable CEXIT3 CNMS4240<br/>Uses Cnmsmsg to send data CSNDDAT CNMS4241<br/>Uses WAIT FOR DATA CWATDAT CNMS4242<br/>Sample DSIEX02A changes a WTO to an MLWTO CEXIT2A CNMS4243<br/>Uses Cnmcnmi to forward RUs to a PU CCNMI CNMS4244<br/>Uses Cnmkio for I/O to VSAM CKEYIO CNMS4245<br/>HLL command using Cnmscop for command authorization<br/>checking<br/></p>
<p>CSCOPCK CNMS4246<br/></p>
<p>Display full screen VIEW panel CFLVIEW CNMS4247<br/>Activates LU and uses TRAP and WAIT to determine if activation<br/>is successful<br/></p>
<p>CACTLU CNMS4248<br/></p>
<p>Uses Cnmsmsg to log text to a sequential log CSEQLOG CNMS4249<br/>DST initialization exit for USERVSAM DST CXITDI CNMS4250<br/>Primes VSAM empty data set for USERVSAM DST CXITVN CNMS4251<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><i>Table 21. C Samples Shipped with the NetView Program (continued)<br/><b></b></i><b>Sample Function C Alias Sample CNMSAMP<br/></b>Sends a request to USERVSAM DST CSNDDST CNMS4252<br/>Processes VSAM requests under USERVSAM DST CDOVSAM CNMS4253<br/>Primes VSAM empty data set for CKEYIO CPRIME CNMS4254<br/>Sends a software alert to an application over the high performance<br/>transport<br/></p>
<p>CHSNDMU CNMS4256<br/></p>
<p>Uses CNMQAPI to access an RODM CRODMCON CNMS4260<br/>Sends an MSU directly to the automation table for evaluation CAUTOTB CNMS4261<br/>Registers or deregisters an application as an MS application on an<br/>operations management served application<br/></p>
<p>CREGISTR CNMS4262<br/></p>
<p>Sends a software alert to ALERT_NETOP from an MS application CSENDMU CNMS4263<br/>Registers an application with the high performance transport CHREGSTR CNMS4264<br/>HLL call to process MDB service CPRSMDB CNMS4269<br/>Uses the PIPE command to activate an LU, wait and trap the<br/>output messages<br/></p>
<p>CACTPIP CNMS4405<br/></p>
<p><b>CTMPPLT (CNMS4201)<br/></b>A template for commands and installation exit routines in C. It is included in<br/>Chapter 9, &#8220;C high-level language services,&#8221; on page 117.<br/></p>
<p><b>CEXIT3 (CNMS4240)<br/></b>A sample DSIEX03 that sets a task global variable. This global variable contains the<br/>value of the last time that a command other than CSNDDAT was entered under an<br/>operator station task (OST). CWATDAT and CSNDDAT are used to interrogate this<br/>value. The HLL service routines used in this sample are <i>Cnminfc </i>and <i>Cnmvars</i>.<br/></p>
<p><b>CSNDDAT (CNMS4241)<br/></b>Uses <i>Cnmsmsg </i>to send data. It is part of an example of sending messages<br/>containing a request, waiting on the response, and parsing the results.<br/></p>
<p>The example finds the last time that a command was entered on a given OST. A<br/>task global variable is set by CEXIT3 every time a command is entered on an OST.<br/>CWATDAT uses <i>Cnmsmsg </i>to issue a CSNDDAT on the task in question.<br/>CWATDAT then goes into a wait state. CSNDDAT retrieves the value of the global<br/>variable and uses <i>Cnmsmsg </i>to send the data back to the task that issued the<br/>CWATDAT. CWATDAT breaks out of the wait state (it has received the data it was<br/>waiting for), and parses and displays the data.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmvars, Cnmsmsg</i>, and <i>Cnminfc</i>.<br/></p>
<p><b>CWATDAT (CNMS4242)<br/></b>Uses WAIT FOR DATA. It is part of an example of sending messages with a type<br/>of request, waiting on the response, and parsing the results.<br/></p>
<p>Its purpose is to find the last time that a command was entered on a given OST. A<br/>task global variable is set by CEXIT3 every time a command is entered on an OST.<br/></p>
<p><b>C Samples<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>CWATDAT uses <i>Cnmsmsg </i>to issue a CSNDDAT on the task in question.<br/>CWATDAT then goes into a wait state. CSNDDAT retrieves the value of the global<br/>variable and uses <i>Cnmsmsg </i>to send the data back to the task that issued the<br/>CWATDAT. CWATDAT breaks out of the wait state (it has received the data it was<br/>waiting for), and parses and displays the data.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmsmsg, Cnmcmd</i>, and <i>Cnmgetd</i>.<br/></p>
<p><b>CEXIT2A (CNMS4243)<br/></b>An exit that converts a write-to-operator (WTO) to an MLWTO by adding two<br/>lines to the single-line WTOs that are driving the exit. The HLL service routines<br/>used in this sample are <i>Cnmgetd </i>and <i>Cnmaltd</i>.<br/></p>
<p><b>CCNMI (CNMS4244)<br/></b>This sample uses <i>Cnmcnmi </i>to send RUs to a PU requesting that the product set ID<br/>be returned. Any data returned is sent as a message to the operator. The prolog of<br/>the sample contains instructions for setup.<br/></p>
<p>The NetView program provides the <i>Cnmcnmi </i>service routine for communicating<br/>with devices in the network through the CNMI. You can access any data that is<br/>returned using the <i>Cnmgetd </i>service routine to retrieve records from the CNMI<br/>solicited data queue (CNMIQ).<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmcnmi, Cnmgetd</i>, and <i>Cnmsmsg</i>.<br/></p>
<p><b>CKEYIO (CNMS4245)<br/></b>Shows how to code a NetView HLL command processor that allows input/output<br/>to a VSAM file through the <i>Cnmkio </i>routine. The command processor must run on a<br/>DST. To run this command, use the EXCMD command or the <i>Cnmsmsg </i>service<br/>routine (with a type of COMMAND). The prolog of the sample explains how to set<br/>up a DST.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmkio </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CSCOPCK (CNMS4246)<br/></b>Shows the command authorization checking capabilities provided by the NetView<br/>program. It authorizes keywords and values using the CSCOPCK command. For<br/>the command, set up:<br/>v Operator ID<br/>v Operator classes that can access the command<br/>v Operator profile<br/></p>
<p>Refer to the prolog of the sample for more information. This command yields a<br/>message if the operator is not authorized to use the keyword and value specified<br/>when invoking the command.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmscop </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>C Samples<br/></b></p>
<p>Appendix D. C samples <b>283</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>CFLVIEW (CNMS4247)<br/></b>Illustrates the use of the full-screen VIEW command processor.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmcmd </i>and <i>Cnmvars</i>.<br/></p>
<p><b>CACTLU (CNMS4248)<br/></b>Shows how to issue a VTAM command to activate an LU, trap the VTAM<br/>messages that result, and respond depending on the messages received.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmcmd</i>, <i>Cnmgetd</i>, and <i>Cnmsmsg</i>.<br/></p>
<p><b>CSEQLOG (CNMS4249)<br/></b>Uses <i>Cnmsmsg </i>to log text to a sequential log. The prolog of the sample contains<br/>instructions for setup.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnminfc </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CXITDI (CNMS4250)<br/></b>Illustrates the DST initialization exit that is used by the USERVSAM DST. The HLL<br/>service routines used in this sample are <i>Cnmvars </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CXITVN (CNMS4251)<br/></b>Prepares a VSAM empty data set for the USERVSAM DST.<br/></p>
<p><b>CSNDDST (CNMS4252)<br/></b>Sends a PUT or GET request to the sample HLL data services command processor<br/>CDOVSAM to store and retrieve a given value for a specified key (key and value<br/>limited to 11 characters in length). The sample also allows a specified NetView<br/>command list language variable (defined by the caller) to be set to the retrieved<br/>value.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmsmsg, Cnmvars, Cnmgetd</i>, and<br/><i>Cnmcmd</i>.<br/></p>
<p><b>CDOVSAM (CNMS4253)<br/></b>Is an HLL data services command processor that runs under the sample data<br/>services task (task ID USERVSAM). The command processor processes PUT or GET<br/>requests sent by the CSNDDST sample, and writes or reads an 11-character value<br/>associated with an 11-character key to the sample DST&#8217;s VSAM data set. The<br/>prolog of CDOVSAM contains instructions on installing the sample USERVSAM<br/>data services task.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmsmsg </i>and <i>Cnmkio</i>.<br/></p>
<p><b>CPRIME (CNMS4254)<br/></b>Prepares a VSAM empty data set for CKEYIO.<br/></p>
<p><b>C Samples<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>CHSNDMU (CNMS4256)<br/></b>Sends a software alert to an application over the high performance transport.<br/></p>
<p>The HLL service routines used are <i>Cnmhsmu </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CRODMCON (CNMS4260)<br/></b>Starts CNMQAPI which enables the user to access a RODM under the control of<br/>the NetView program. The coded example shows a RODM CONNECT function.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmsmsg </i>and <i>Cnmqapi</i>.<br/></p>
<p><b>CAUTOTB (CNMS4261)<br/></b>Sends an MSU directly to the automation table for evaluation. It provides a<br/>method of testing automation table statements without sending an alert through<br/>the hardware monitor.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmauto, Cnmsmsg, </i>and <i>Cnmscan</i>.<br/></p>
<p><b>CREGISTR (CNMS4262)<br/></b>Registers or deregisters an application as an MS application or an operations<br/>management served application.<br/></p>
<p>Provide the following information:<br/>v Application name<br/>v Command name<br/>v Logmode<br/>v Replace option<br/>v Registration type<br/></p>
<p>Refer to the prolog of the sample for more information. This command sends a<br/>message to the invoking operator that reports the return code from the registration<br/>or deregistration.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmrgs </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CSENDMU (CNMS4263)<br/></b>Sends a software alert to ALERT_NETOP from an MS application.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmsmu </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CHREGSTR (CNMS4266)<br/></b>Registers an application with the high performance transport.<br/></p>
<p>Provide the following information:<br/>v Application name<br/>v Command name<br/>v Replace option<br/></p>
<p><b>C Samples<br/></b></p>
<p>Appendix D. C samples <b>285</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>v Registration type<br/>v Focal point category<br/>v Focal point option<br/>v Notify option<br/></p>
<p>Refer to the prologue of the sample for more information. This command sends a<br/>message to the invoking operator that reports the return code from the registration<br/>or deregistration.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmhrgs </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CPRSMDB (CNMS4269)<br/></b>This HLL sample sends an MDB to the NetView program for processing. The MDB<br/>is a designed structure for message data. The MDB structure is mapped by the<br/>MVS control block IEAVM105. The HLL service routines used in this sample are<br/><i>Cnmpmdb </i>and <i>Cnmsmsg</i>.<br/></p>
<p><b>CACTPIP (CNMS4405)<br/></b>Shows how to use the PIPE command to issue a VTAM command which activates<br/>an LU, traps the resulting VTAM messages, and responds depending on the<br/>messages received.<br/></p>
<p>The HLL service routines used in this sample are <i>Cnmvlc</i>, <i>Cnmvars</i>, <i>Cnmcmd</i>, and<br/><i>Cnmsmsg</i>.<br/></p>
<p><b>C Samples<br/></b></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Notices<br/></b>This information was developed for products and services offered in the U.S.A.<br/></p>
<p>IBM may not offer the products, services, or features discussed in this document in<br/>other countries. Consult your local IBM representative for information on the<br/>products and services currently available in your area. Any reference to an IBM<br/>product, program, or service is not intended to state or imply that only that IBM<br/>product, program, or service may be used. Any functionally equivalent product,<br/>program, or service that does not infringe any IBM intellectual property right may<br/>be used instead. However, it is the user's responsibility to evaluate and verify the<br/>operation of any non-IBM product, program, or service.<br/></p>
<p>IBM may have patents or pending patent applications covering subject matter<br/>described in this document. The furnishing of this document does not give you<br/>any license to these patents. You can send license inquiries, in writing, to:<br/></p>
<p>IBM Director of Licensing<br/>IBM Corporation<br/>North Castle Drive<br/>Armonk, NY 10504-1785<br/>U.S.A.<br/></p>
<p>For license inquiries regarding double-byte (DBCS) information, contact the IBM<br/>Intellectual Property Department in your country or send inquiries, in writing, to:<br/></p>
<p>Intellectual Property Licensing<br/>Legal and Intellectual Property Law<br/>IBM Japan, Ltd.<br/>19-21, Nihonbashi-Hakozakicho, Chuo-ku<br/>Tokyo 103-8510, Japan<br/></p>
<p><b>The following paragraph does not apply to the United Kingdom or any other<br/>country where such provisions are inconsistent with local law</b>:<br/></p>
<p>INTERNATIONAL BUSINESS MACHINES CORPORATION PROVIDES THIS<br/>PUBLICATION &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER<br/>EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED<br/>WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS<br/>FOR A PARTICULAR PURPOSE.<br/></p>
<p>Some states do not allow disclaimer of express or implied warranties in certain<br/>transactions, therefore, this statement might not apply to you.<br/></p>
<p>This information could include technical inaccuracies or typographical errors.<br/>Changes are periodically made to the information herein; these changes will be<br/>incorporated in new editions of the publication. IBM may make improvements<br/>and/or changes in the product(s) and/or the program(s) described in this<br/>publication at any time without notice.<br/></p>
<p>Any references in this information to non-IBM Web sites are provided for<br/>convenience only and do not in any manner serve as an endorsement of those Web<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>sites. The materials at those Web sites are not part of the materials for this IBM<br/>product and use of those Web sites is at your own risk.<br/></p>
<p>IBM may use or distribute any of the information you supply in any way it<br/>believes appropriate without incurring any obligation to you.<br/></p>
<p>Licensees of this program who wish to have information about it for the purpose<br/>of enabling: (i) the exchange of information between independently created<br/>programs and other programs (including this one) and (ii) the mutual use of the<br/>information which has been exchanged, should contact:<br/></p>
<p>IBM Corporation<br/>2Z4A/101<br/>11400 Burnet Road<br/>Austin, TX 78758<br/>U.S.A.<br/></p>
<p>Such information may be available, subject to appropriate terms and conditions,<br/>including in some cases payment of a fee.<br/></p>
<p>The licensed program described in this document and all licensed material<br/>available for it are provided by IBM under terms of the IBM Customer Agreement,<br/>IBM International Program License Agreement or any equivalent agreement<br/>between us.<br/></p>
<p>Information concerning non-IBM products was obtained from the suppliers of<br/>those products, their published announcements or other publicly available sources.<br/>IBM has not tested those products and cannot confirm the accuracy of<br/>performance, compatibility or any other claims related to non-IBM products.<br/>Questions on the capabilities of non-IBM products should be addressed to the<br/>suppliers of those products.<br/></p>
<p>COPYRIGHT LICENSE:<br/></p>
<p>This information contains sample application programs in source language, which<br/>illustrate programming techniques on various operating platforms. You may copy,<br/>modify, and distribute these sample programs in any form without payment to<br/>IBM, for the purposes of developing, using, marketing or distributing application<br/>programs conforming to the application programming interface for the operating<br/>platform for which the sample programs are written. These examples have not<br/>been thoroughly tested under all conditions. IBM, therefore, cannot guarantee or<br/>imply reliability, serviceability, or function of these programs. You may copy,<br/>modify, and distribute these sample programs in any form without payment to<br/>IBM for the purposes of developing, using, marketing, or distributing application<br/>programs conforming to IBM&#8217;s application programming interfaces.<br/></p>
<p>Each copy or any portion of these sample programs or any derivative work, must<br/>include a copyright notice as follows:<br/></p>
<p>&#169; (your company name) (year). Portions of this code are derived from IBM Corp.<br/>Sample Programs. &#169; Copyright IBM Corp. _enter the year or years_. All rights<br/>reserved.<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Programming Interfaces<br/></b>This publication documents intended Programming Interfaces that allow the<br/>customer to write programs to obtain the services of Tivoli NetView for z/OS.<br/></p>
<p><b>Trademarks<br/></b>IBM, the IBM logo, and ibm.com&#174; are trademarks or registered trademarks of<br/>International Business Machines Corp., registered in many jurisdictions worldwide.<br/>Other product and service names might be trademarks of IBM or other companies.<br/>A current list of IBM trademarks is available on the Web at &#8220;Copyright and<br/>trademark information&#8221; at http://www.ibm.com/legal/copytrade.shtml .<br/></p>
<p>Adobe is a trademark of Adobe Systems Incorporated in the United States, and/or<br/>other countries.<br/></p>
<p>Java and all Java-based trademarks and logos are trademarks or registered<br/>trademarks of Oracle and/or its affiliates.<br/></p>
<p>Linux is a registered trademark of Linus Torvalds in the United States, other<br/>countries, or both.<br/></p>
<p>Microsoft and Windows are trademarks of Microsoft Corporation in the United<br/>States, other countries, or both.<br/></p>
<p>UNIX is a registered trademark of The Open Group in the United States and other<br/>countries.<br/></p>
<p>Other product and service names might be trademarks of IBM or other companies.<br/></p>
<p><b>Privacy policy considerations<br/></b>IBM Software products, including software as a service solutions, (&#8220;Software<br/>Offerings&#8221;) may use cookies or other technologies to collect product usage<br/>information, to help improve the end user experience, to tailor interactions with<br/>the end user or for other purposes. In many cases no personally identifiable<br/>information is collected by the Software Offerings. Some of our Software Offerings<br/>can help enable you to collect personally identifiable information. If this Software<br/>Offering uses cookies to collect personally identifiable information, specific<br/>information about this offering&#8217;s use of cookies is set forth below.<br/></p>
<p>This Software Offering does not use cookies or other technologies to collect<br/>personally identifiable information.<br/></p>
<p>If the configurations deployed for this Software Offering provide you as customer<br/>the ability to collect personally identifiable information from end users via cookies<br/>and other technologies, you should seek your own legal advice about any laws<br/>applicable to such data collection, including any requirements for notice and<br/>consent.<br/></p>
<p>For more information about the use of various technologies, including cookies, for<br/>these purposes, See IBM&#8217;s Privacy Policy at http://www.ibm.com/privacy and<br/>IBM&#8217;s Online Privacy Statement at http://www.ibm.com/privacy/details the<br/>section entitled &#8220;Cookies, Web Beacons and Other Technologies&#8221; and the &#8220;IBM<br/>Software Products and Software-as-a-Service Privacy Statement&#8221; at<br/>http://www.ibm.com/software/info/product-privacy.<br/></p>
<p>Notices <b>289</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p><b>Index<br/>Special characters<br/></b>(\0) end-of-string character 109<br/>&amp; (address) operator 106, 107<br/>&amp;HDRMTYPE variable 207<br/>&amp;LINETYPE variable 207<br/>&amp;MSGID variable 207<br/>&amp;MSGORIGIN variable 207<br/>&amp;PARMSTR variable 62<br/>&amp;PAUSE function 72, 134<br/>#pragma C variable 39<br/>{} type specifier 248<br/></p>
<p><b>A<br/></b>AAUTSKLP subtask 22<br/>abbreviate command 17<br/>access<br/></p>
<p>command list variable<br/>C example 130<br/>PL/I example 70<br/></p>
<p>data 4<br/>data set 80, 144<br/>servers across hosts 8<br/>storage 79, 143<br/>VSAM file 83<br/></p>
<p>accessibility xvii<br/>ACTIONDL, CNMGETA attribute 194<br/>ACTIONMG, CNMGETA attribute 194<br/>adbuf operand 184<br/>ADDR function<br/></p>
<p>description 53<br/>IEL0872I message 53<br/>passing pointer variables 52<br/></p>
<p>address of the HLB control block 103<br/>addressing mode 44<br/>adfunc operand 184<br/>adindex operand 184<br/>adorigin operand 54, 108, 184<br/>adqueue operand 184<br/>alert<br/></p>
<p>high-performance transport<br/>C example 161<br/>PL/I example 96<br/></p>
<p>MS transport<br/>C example 160<br/>PL/I example 95<br/></p>
<p>alias, C sample 281<br/>ALLOCATE command 7, 56, 113<br/>allocating files, PL/I 56<br/>altering data<br/></p>
<p>C example 141<br/>PL/I example 78<br/></p>
<p>API (application program interface) 4<br/>application registration<br/></p>
<p>with high-performance transport 94, 159<br/>with MS transport 92, 158, 241<br/></p>
<p>argc parameter in C 103<br/>argv parameter in C 103<br/>asynchronous<br/></p>
<p>command running 3<br/></p>
<p>asynchronous <i>(continued)<br/></i>panel update 4<br/></p>
<p>atdata operand 185<br/>ATTNID, CNMGETA attribute 195<br/>AUTCONID 218<br/>authorization checking<br/></p>
<p>command 75, 138<br/>command, keyword, value 249<br/>logon 18<br/></p>
<p>authorized receiver 251<br/>automating MSUs<br/></p>
<p>C example 157<br/>PL/I example 90<br/></p>
<p>automating NetView messages 4<br/>AUTOTOKE, CNMGETA attribute 195<br/></p>
<p><b>B<br/></b>BNJDSERV subtask 22<br/>BNJNETOP data set 22<br/>BNJPALEX installation exit 13, 14<br/>BNJPNL1 data set 232<br/>BNJPNL2 data set 232<br/>books<br/></p>
<p>see publications xiii<br/>BSAM 21<br/>building request units, CNMI 119<br/></p>
<p><b>C<br/></b>C control blocks, description 112<br/>C examples<br/></p>
<p>accessing command list variables 130<br/>altering data 141<br/>automating MSUs 157<br/>CNMI 145<br/>coding DST installation exits 151<br/>coding installation exits 152<br/>coding WAIT FOR DATA 153<br/>command authorization checking 138<br/>data set access 144<br/>Hlbrc C return code field 12<br/>invoking synchronous commands 123<br/>keyed file access 149<br/>locks 133<br/>message processing 137<br/>operator input 134<br/>registering applications<br/></p>
<p>high-performance transport 159<br/>MS transport 158<br/>operations management 158<br/></p>
<p>registering applications, MS transport 158<br/>registering applications, operations management 158<br/>retrieving information 129<br/>sending alerts, MS transport 160<br/>sending commands 123<br/>sending data, high-performance transport 161<br/>sending MDB to NetView 162<br/>sending messages 122<br/>storage access 143<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>C examples <i>(continued)<br/></i>translating code points 158<br/>VIEW command processor 136<br/>VSAM access 149<br/>waiting, trapping 125<br/></p>
<p>C I/O considerations 113<br/>C include files<br/></p>
<p>description 112<br/>DSIC 112, 279<br/>DSICCALL 113, 279<br/>DSICCNM 113, 279<br/>DSICCONS 113, 279<br/>DSICHLB 113, 279<br/>DSICORIG 113, 279<br/>DSICPRM 113, 279<br/>DSICVARC 113, 279<br/></p>
<p>C module, coding<br/>interfaces 103<br/>restrictions 115<br/></p>
<p>C program<br/>installation exits, performance considerations 12<br/>interfaces 103<br/>production environment 114<br/>restrictions 103<br/>test environment 114<br/></p>
<p>C programs, coding initial parameters 103<br/>C runtime considerations 114<br/>C runtime options 103<br/>C sample template 117<br/>C samples<br/></p>
<p>CACTLU (CNMS4248) 284<br/>CACTPIP (CNMS4405) 127, 286<br/>CAUTOTB (CNMS4261) 285<br/>CCNMI (CNMS4244) 283<br/>CDOVSAM (CNMS4253) 14, 284<br/>CEXIT2A (CNMS4243) 13, 283<br/>CEXIT3 (CNMS4240) 13, 282<br/>CFLVIEW (CNMS4247) 284<br/>CHREGSTR (CNMS4266) 285<br/>CHSNDMU (CNMS4256) 285<br/>CKEYIO (CNMS4245) 14, 283<br/>CPRIME (CNMS4254) 14, 284<br/>CPRSMDB (CMS4269) 286<br/>CREGISTR (CNMS4262) 285<br/>CRODMCON (CMS4260) 285<br/>CSCOPCK (CNMS4246) 283<br/>CSENDMU (CNMS4263) 285<br/>CSEQLOG (CNMS4249) 284<br/>CSNDDAT (CNMS4241) 13, 282<br/>CSNDDST (CNMS4252) 284<br/>CTMPPLT (CNMS4201) 282<br/>CWATDAT (CNMS4242) 13, 282<br/>CXITDI (CNMS4250) 14, 284<br/>CXITVN (CNMS4251) 14, 284<br/>table of 281<br/></p>
<p>c type specifier 247<br/>C/C++ programs<br/></p>
<p>TRAP(OFF) option 104<br/>C/C++programs<br/></p>
<p>achieving optimum performance 104<br/>CACTLU (CNMS4248) C sample 284<br/>CACTPIP (CNMS4405) C sample 127, 286<br/>cancelable, defining programs 39<br/>cancelling a command procedure 179<br/>cancelling and terminating HLL program 39<br/>CART, CNMGETA attribute 195<br/>CAUTOTB (CNMS4261) C sample 285<br/></p>
<p>CCNMI (CNMS4244) C sample 283<br/>CDOVSAM (CNMS4253) C sample 14, 284<br/>CEEUOPT CSECT 50<br/>CEXIT2A (CNMS4243) C sample 13, 283<br/>CEXIT3 (CNMS4240) C sample 13, 282<br/>CFLVIEW (CNMS4247) C sample 284<br/>change bars xix<br/>character strings<br/></p>
<p>parsing 7<br/>varying length 119<br/></p>
<p>checking authorization 18<br/>CHREGSTR (CNMS4266) C sample 285<br/>CHSNDMU (CNMS4256) C sample 285<br/>CKEYIO (CNMS4245) C sample 14, 283<br/>client and server requests, response handling 3<br/>CLOCK 218<br/>close partitioned data set 231<br/>Cmdbuf 103<br/></p>
<p>description 103<br/>initial parameter in C 103<br/>qualification, using DSIEX02A 103<br/></p>
<p>CMDBUF<br/>initial parameter in PL/I 49<br/>replace a message 12<br/></p>
<p>CMDDEF statement required to run HLL program 115<br/>cmdstr operand 187<br/>cndata operand 189<br/>cndest operand 189<br/>cnfunc operand 189<br/>CNM<br/></p>
<p>data services 28<br/>interface, sending and receiving data 6<br/>request 22<br/></p>
<p>CNM987I message 170<br/>CNM988I message 170<br/>CNMALTD (CNMALTDATA) service routine<br/></p>
<p>description 183<br/>syntax 183<br/></p>
<p>CNMAUTO (CNMAUTOTAB) service routine 185<br/>CNMC2T (CNMCODE2TXT) service routine 192<br/>CNMCELL (CNMSTRCELL) service routine<br/></p>
<p>description 186, 237<br/>syntax 186<br/></p>
<p>CNMCMD (CNMCOMMAND)<br/>issuing operator commands 175<br/></p>
<p>CNMCMD (CNMCOMMAND) service routine<br/>description 187<br/>syntax 187<br/></p>
<p>CNMCMD data set member 249<br/>CNMCMD service routine<br/></p>
<p>excluding, installation exits 11<br/>CNMCNMI (CNMI) service routine<br/></p>
<p>description 189<br/>example 81, 145<br/>excluding, installation exits 11<br/>syntax 189<br/></p>
<p>CNMCPYS (CNMCOPYSTR) service routine<br/>description 190<br/>example 106<br/></p>
<p>CNMCSSIR 13<br/>CNMGETA (CNMGETATTR) service routine 193<br/>CNMGETD (CNMGETDATA) service routine<br/></p>
<p>description 134, 204<br/>example 145<br/>syntax 204<br/></p>
<p>CNMGETD function 61<br/>CNMHRGS (CNMHREGIST) service routine 208<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>CNMHSMU (CNMHSENDMU) service routine 212<br/>CNMI<br/></p>
<p>building request units 119<br/>C example 145<br/>interface required by DST 27<br/>PL/I example 81<br/></p>
<p>CNMINFC (CNMINFOC) service routine<br/>description 69, 218<br/>syntax 218<br/></p>
<p>CNMINFI (CNMINFOI) service routine<br/>description 69, 221<br/>syntax 221<br/></p>
<p>CNMIPXL (CNMIPXLATE) service routine<br/>description 224<br/>syntax 224<br/></p>
<p>CNMIQ access queue 61, 121, 207<br/>CNMKIO (CNMKEYIO) service routine<br/></p>
<p>description 227<br/>excluding, installation exits 11<br/>syntax 227<br/></p>
<p>CNMLK (CNMLOCK) service routine<br/>description 57, 229<br/>syntax 229<br/></p>
<p>CNMMEMC (CNMCLOSMEM) service routine<br/>description 80, 144, 231<br/>syntax 231<br/></p>
<p>CNMMEMO (CNMOPENMEM) service routine<br/>description 80, 144, 232<br/>syntax 232<br/></p>
<p>CNMMEMR (CNMREADMEM) service routine<br/>description 80, 144, 233<br/>syntax 233<br/></p>
<p>CNMNAMS (CNMNAMESTR) service routine 234<br/>Cnmnvlc C convert string 109, 111, 120<br/>CNMPMDB (CNMPRSMDB) service routine 236<br/>CNMPNL1 data set 232<br/>CNMPOOL (CNMSTRPOOL) service routine<br/></p>
<p>description 237<br/>example 108<br/></p>
<p>CNMQAPI (CNMOPREP) service routine 239<br/>CNMRGS (CNMREGIST) service routine 241<br/>CNMSCAN (CNMSSCAN) service routine 246<br/>CNMSCOP (CNMSCOPECK) service routine 249<br/>CNMSMSG (CNMSENDMSG) service routine<br/></p>
<p>description 17, 26, 251<br/>excluding, installation exits 11<br/>syntax 251<br/></p>
<p>CNMSMU (CNMSENDMU) service routine 254<br/>CNMSUBS 261<br/>CNMSUBSYM 261<br/>CNMVARS (CNMVARPOOL) service routine 263<br/>Cnmvlc C convert string 109, 110, 119<br/>cntimout operand 189<br/>CNVTOHEX constant 111, 112<br/>code<br/></p>
<p>C program<br/>interfaces 103<br/>restrictions 103<br/></p>
<p>PL/I program<br/>environment 49<br/>interfaces 49<br/>restrictions 49<br/></p>
<p>code points, translating<br/>C example 158<br/>PL/I example 91<br/></p>
<p>code template 59, 117<br/></p>
<p>coding DST installation exits<br/>C example 151<br/>concatenating 13<br/>PL/I example 85<br/></p>
<p>coding installation exits<br/>C example 152<br/>PL/I example 86<br/></p>
<p>coding WAIT FOR DATA<br/>C example 153<br/>PL/I example 87<br/></p>
<p>command authorization 75, 138, 249<br/>command cancellation 179<br/>command line, Cmdbuf 103<br/>command list variable, accessing 5, 130<br/>command processor<br/></p>
<p>environment 223<br/>non-preinitialized environments, steps for<br/></p>
<p>implementing 34<br/>PL/I support 49<br/>preinitialized environments, steps for implementing 34<br/>VIEW 136<br/></p>
<p>commands<br/>abbreviation 17<br/>ALLOCATE 7<br/>authorization 249<br/>CNMSCOP service routine 249<br/>FREE 7<br/>PIPE 177<br/>sending with C 123<br/>sending with PL/I 65<br/>synchronous execution 123<br/>synchronous invocation 65<br/>synchronous running 3<br/>synonym 17<br/>verifying authorization 16<br/></p>
<p>commands, HLL<br/>GLOBALV 175<br/>overview 175<br/>QUEUE 178<br/>RESET 175, 179<br/></p>
<p>common global (CGLOBAL)<br/>command list variable 5<br/>pool 263, 265<br/>variables 70, 130, 133<br/></p>
<p>common global pool 264<br/>common global variables 130<br/>communicating with devices 81, 145<br/>communications network management interface (CNMI) 189<br/>completion code 58, 115<br/>concatenate DST installation exits 13<br/>control blocks<br/></p>
<p>C 112, 279<br/>PL/I 55, 269<br/></p>
<p>control line message 252<br/>controlling locks 229<br/>conventions<br/></p>
<p>typeface xix<br/>converting<br/></p>
<p>DSICCONS 111, 112<br/>hexadecimal 111, 112<br/>initial parameters, sscanf 103<br/></p>
<p>copying storage 7<br/>correlarea operand 212<br/>CPRIME (CNMS4254) C sample 14, 284<br/>CPRSMDB (CMS4269) C sample 286<br/>CPU time (TOD Clock) 220<br/>CREGISTR (CNMS4262) C sample 285<br/></p>
<p>Index <b>293</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>critical preinitialized programs 40<br/>CRODMCON (CMS4260) C sample 285<br/>cross-domain<br/></p>
<p>alert 22<br/>command 17<br/>traffic, monitor 17<br/></p>
<p>CSCOPCK (CNMS4246) C sample 283<br/>CSENDMU (CNMS4263) C sample 285<br/>CSEQLOG (CNMS4249) C sample 284<br/>csfrom operand 191<br/>cslen operand 191<br/>CSNDDAT (CNMS4241) C sample 13, 282<br/>CSNDDST (CNMS4252) C sample 284<br/>csto operand 191<br/>cstype operand 191<br/>CTMPPLT (CNMS4201) C sample 282<br/>CURCONID 219<br/>current date function 219<br/>CURSYS 219<br/>customization, check 18<br/>cvdata operand 263<br/>cvdatlen operand 263<br/>cvfunc operand 263<br/>cvname operand 264<br/>cvpool operand 264<br/>CWATDAT (CNMS4242) C sample 13, 282<br/>CXITDI (CNMS4250) C sample 14, 284<br/>CXITVN (CNMS4251) C sample 14, 284<br/></p>
<p><b>D<br/></b>d type specifier 247<br/>data access 4<br/>data alteration 78, 141<br/>data definition (DD) statement 56, 113<br/>data queue 5<br/>data queue management 61, 121<br/>data set access<br/></p>
<p>C example 144<br/>closing 231<br/>opening 232<br/>PL/I example 80<br/></p>
<p>data sets, access from HLL 7<br/>data, requesting<br/></p>
<p>C 154<br/>PL/I 88<br/></p>
<p>data, sending<br/>C 156<br/>PL/I 89<br/></p>
<p>DATAQ access queue 61, 121, 207<br/>datatype operand 214<br/>DATE 219<br/>DATETIM2 219<br/>DATETIME 219<br/>deallocate files<br/></p>
<p>deallocating files 56<br/>dynamically 7<br/>PL/I 56<br/></p>
<p>debug support<br/>remote interactive debugger (RID) 8, 167<br/>traces 8<br/></p>
<p>DELAY, avoiding 58<br/>deleting a message 12<br/>deliver request unit (RU) 22<br/>DESC, CNMGETA attribute 195<br/>destappl operand 213<br/>destlu operand 213<br/></p>
<p>destnet operand 213<br/>device communications 81, 145<br/>directory names, notation xix<br/>DISCORIG, mapping Origblck 103<br/>DISPLAY, avoiding 58<br/>domain ID 207, 219<br/>DSCP 28<br/>DSIC C include file 109, 112, 279<br/>DSICCALL C include file 113, 279<br/>DSICCNM<br/></p>
<p>C include file 113, 279<br/>resolving composite return codes 173<br/></p>
<p>DSICCONS C include file 108, 113, 279<br/>DSICES macro 188<br/>DSICHLB C include file 279<br/>DSICLD data set 232<br/>DSICORIG C include file 113, 279<br/>DSICPRM C include file 113, 279<br/>DSICRTR subtask 22<br/>DSICVARC C include file 109, 113, 279<br/>DSIDKS macro 232<br/>DSIEX01 installation exit 13, 14<br/>DSIEX02A installation exit 13, 14<br/>DSIEX03 installation exit 13, 15<br/>DSIEX04 installation exit 13, 15, 16<br/>DSIEX05 installation exit 13, 16<br/>DSIEX06 installation exit 13, 16<br/>DSIEX07 installation exit 13, 17<br/>DSIEX09 installation exit 13, 17<br/>DSIEX10 installation exit 13, 17<br/>DSIEX11 installation exit 13, 17<br/>DSIEX12 installation exit 13, 18<br/>DSIEX13 installation exit 13, 19<br/>DSIEX14 installation exit 13, 19<br/>DSIEX16 installation exit 13, 20<br/>DSIEX16B installation exit 13, 20<br/>DSIEX17 installation exit 13, 20<br/>DSIEX18 installation exit 13, 20<br/>DSIEX19 installation exit 13, 20<br/>DSIEX20 installation exit 13, 21<br/>DSIEX21 installation exit 13, 21<br/>DSIGET macro 178<br/>DSILCS macro 188<br/>DSILOG task 26<br/>DSILOGDS mapping function 26<br/>DSIMQS macro 19, 178<br/>DSIMSG data set 232<br/>DSIOPEN data set 232<br/>DSIPARM data set 232<br/>DSIPCNM PL/I include file 56, 269<br/>DSIPCONS PL/I include file 55, 269<br/>DSIPHLB PL/I include file 55, 269<br/>DSIPHLLS PL/I include file 56, 269<br/>DSIPLI PL/I include file 55, 269<br/>DSIPORIG PL/I include file 55, 269<br/>DSIPPRM PL/I include file 56, 269<br/>DSIPRF data set 232<br/>DSIPSS macro 15<br/>DSIPUSH macro 236<br/>DSITIB control block 223<br/>DSITRACE task 26<br/>DSITVB control block 222, 223<br/>Dsivarch, varying length character string 106, 109, 119<br/>DSIVTAM data set 232<br/>DSIWCS macro 17<br/>DSIZCSMS macro 174<br/>DSRBO keyword 29<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>DST (data services task)<br/>coding<br/></p>
<p>C 151<br/>PL/I 85<br/></p>
<p>described 27<br/>installation exit routine<br/></p>
<p>XITBN 13, 21<br/>XITBO 14, 22<br/>XITCI 14, 22<br/>XITCO 14, 24<br/>XITDI 14, 25<br/>XITVI 14, 25<br/>XITVN 14, 25<br/>XITVO 14, 26<br/>XITXL 14, 26<br/></p>
<p>installation of 27, 190<br/>run commands in C 123<br/>run commands in PL/I 65<br/>run HLL services 57<br/>schedule commands under 29<br/></p>
<p>DST installation exit routine 11<br/>DSTINIT 27, 29<br/>dynamic file allocation, deallocation 7<br/></p>
<p><b>E<br/></b>ECVTPSEQ 219<br/>edit<br/></p>
<p>log information 15<br/>system console messages 17<br/></p>
<p>education<br/>see Tivoli technical training xvii<br/></p>
<p>ELBLENG external logging offset 26<br/>ELBLOG external logging offset 26<br/>ELBRLENG external logging offset 26<br/>ELBTYPE external logging offset 26<br/>empty data set 21, 25<br/>end of multiline message 252<br/>end-of-string character (\0) 109<br/>environment variables, notation xix<br/>environment, PL/I 49<br/>errors, PL/I runtime 57<br/>examples<br/></p>
<p>C<br/>accessing command list variables 130<br/>altering data 141<br/>automating MSUs 157<br/>CNMI 145<br/>coding DST installation exits 151<br/>coding installation exits 152<br/>coding WAIT FOR DATA 153<br/>command authorization checking 138<br/>data queue management 121<br/>data set access 144<br/>DSIEX02A installation exit 14<br/>invoking synchronous commands 123<br/>keyed file access 149<br/>message processing 137<br/>operator input 134<br/>retrieving information 129<br/>sending an MDB to NetView 162<br/>sending commands 123<br/>sending messages 122<br/>storage access 143<br/>translating code points 158<br/>using locks 133<br/>VIEW command processor 136<br/></p>
<p>examples <i>(continued)<br/></i>C <i>(continued)<br/></i></p>
<p>VSAM access 149<br/>waiting, trapping 125<br/></p>
<p>PL/I<br/>altering data 78<br/>CNMI 81<br/>code points, translating 91<br/>coding 85, 86, 87<br/>coding, template 59<br/>command authorization checking 75<br/>command list variable access 70<br/>data queue management 61<br/>data set access 80<br/>invoking synchronous commands 65<br/>MDB, sending to NetView 97<br/>message processing 74<br/>MSUs, automating 90<br/>operator input 72<br/>parsing character strings 62, 63<br/>registering applications 92, 94<br/>retrieving information 69<br/>sending alerts 95, 96<br/>sending commands 65<br/>sending messages 61<br/>storage access 79<br/>using locks 71<br/>VIEW command processor 73<br/>VSAM keyed file access 83<br/>waiting and trapping 66<br/></p>
<p>resolving composite return codes 173<br/>external C variable, HLLOPTS<br/></p>
<p>HLL_NO_CANCEL runtime option 39<br/>HLL_QUEUED_INPUT runtime option 38<br/>syntax 38<br/></p>
<p>external log (EXTLOG operand) 26, 251<br/>external logging exit (XITXL) 14, 26<br/>external trace log 15<br/></p>
<p><b>F<br/></b>file allocating or deallocating 7<br/>file I/O capability 56, 113<br/>FILE option 57<br/>first failure data capture trace 8<br/>fixed-length character strings 54, 108<br/>fixed-length variable, PL/I example 54<br/>focal point transfer RU header 23<br/>fopen 113<br/>format specifications 111<br/>forward RU 24<br/>FREE command 7, 56, 113<br/>full-screen<br/></p>
<p>capability 136<br/>input/output 4<br/></p>
<p>FUNCT, DSTINIT keyword 27<br/></p>
<p><b>G<br/></b>gadata operand 193<br/>gadatlen operand 194<br/>ganame operand 194<br/>gaqueue operand 204<br/>gdbuf operand 205<br/>gdbuflen operand 205<br/>gdindex operand 206<br/></p>
<p>Index <b>295</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>gdorigin operand 54, 108, 206<br/>gdqueue operand 206<br/>GET statement 57<br/>getchar routine 114, 115<br/>GETDATA function 121<br/>global installation exit 11<br/>global variables 176<br/>GLOBALV command 176<br/>GO command 4, 177<br/></p>
<p><b>H<br/></b>HAPIENTR debug option 168, 171<br/>HAPIEXIT debug option 168, 171<br/>hardcopy log 15, 219<br/>HCOPY 219<br/>HDRMTYPE field 187<br/>hexadecimal conversation 111<br/>high performance transport<br/></p>
<p>description 6<br/>NetView bridge remote access 8<br/>PHREGSTR sample 276<br/>PHSNDMU sample 275<br/></p>
<p>high-level language 3<br/>high-performance transport<br/></p>
<p>API 208, 212<br/>CNMGETD service routine 207<br/>CNMHRGS service routine 210<br/>CNMHSMU service routine 212, 216<br/>data queue management 61, 121<br/>registering applications<br/></p>
<p>C example 159<br/>PL/I example 94<br/></p>
<p>sending alerts<br/>C example 161<br/>PL/I example 96<br/></p>
<p>sending data<br/>C example 161<br/>PL/I example 96<br/></p>
<p>HLB control block 58, 115<br/>Hlbleng C storage field 194, 218, 228<br/>HLBLENG PL/I storage field 194, 218, 228<br/>Hlbptr<br/></p>
<p>C pointer field 106<br/>description 103<br/>initial parameter in C 103<br/>restrictions for Cnmcpys invocation 106<br/></p>
<p>HLBPTR<br/>initial parameter of PL/I program 49<br/>PL/I pointer field 52<br/>restrictions with pointer variables 52<br/></p>
<p>Hlbrc<br/>return code field in C 12<br/></p>
<p>HLBRC<br/>resolving composite return codes 173<br/>return code field in PL/I 12, 58<br/></p>
<p>HLL command processors<br/>coding in C 103<br/>considerations for 57, 115<br/></p>
<p>HLL commands<br/>GO 175, 177<br/>overview 175<br/>QUEUE 175, 178<br/>RESET 179<br/>TRAP 175, 182<br/>WAIT 175, 182<br/></p>
<p>HLL definition facilities<br/>HLLENV command<br/></p>
<p>DEFAULT keyword 38<br/>preinitialized environments, defining 37<br/>REGENVS and CRITENVS keywords 37<br/>storage keywords 37<br/></p>
<p>HLL installation exit routines<br/>invocation restriction 3<br/>overview 11<br/></p>
<p>HLL PL/I restrictions 58<br/>HLL program<br/></p>
<p>accepting queued input 38<br/>end on cancel/reset 39<br/></p>
<p>HLL runtime options<br/>default values 38<br/>specifying, HLLOPTS 38<br/></p>
<p>HLL service routines<br/>CNMALTD (CNMALTDATA) 183<br/>CNMAUTO (CNMAUTOTAB) 185<br/>CNMC2T (CNMCODE2TXT) 192<br/>CNMCELL (CNMSTRCELL) 186<br/>CNMCMD(CNMCOMMAND) 187<br/>CNMCNMI (CNMI) 189<br/>CNMCPYS (CNMCOPYSTR) 190<br/>CNMGETA (CNMGETATTR) 193<br/>CNMGETD (CNMGETDATA) 204<br/>CNMHRGS (CNMHREGIST) 208<br/>CNMHSMU (CNMHSENDMU) 212<br/>CNMINFC (CNMINFOC) 218<br/>CNMINFI (CNMINFOI) 221<br/>CNMIPXL (CNMIPXLATE) 224<br/>CNMKIO(CNMKEYIO) 227<br/>CNMLK (CNMLOCK) 229<br/>CNMMEMC (CNMCLOSMEM) 231<br/>CNMMEMO (CNMOPENMEM) 232<br/>CNMMEMR (CNMREADMEM) 233<br/>CNMMMDB (CNMMMDBPRS) 236<br/>CNMNAMS (CNMNAMESTR) 234<br/>CNMPOOL (CNMSTRPOOL) 237<br/>CNMQAPI (CNMOPREP) 239<br/>CNMRGS (CNMREGIST) 241<br/>CNMSCAN (CNMSSCAN) 246<br/>CNMSCOP (CNMSCOPECK) 249<br/>CNMSMSG (CNMSENDMSG) 251<br/>CNMSMU (CNMSENDMU) 254<br/>CNMVARS (CNMVARPOOL) 263<br/>description 183<br/>input parameters<br/></p>
<p>fixed-length character strings 54<br/>integer variables 53<br/>pointer variables 52<br/>varying-length character strings 54<br/></p>
<p>HLL_NO_CANCEL runtime option<br/>description 39<br/></p>
<p>HLL_QUEUED_INPUT runtime option 38<br/>HLL, description 3<br/>HLLENV command<br/></p>
<p>REGENVS and CRITENVS keywords<br/>critical programs 37<br/>programs 37<br/></p>
<p>HLLOPTS external C variable<br/>HLL_NO_CANCEL runtime option 39<br/>HLL_QUEUED_INPUT runtime option 38<br/>syntax 38<br/></p>
<p>hrapplname operand 208<br/>hrcmdname operand 209<br/>hrlogmod 209<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>hrreplvalue operand 210<br/>hrtype operand 210<br/></p>
<p><b>I<br/></b>I/O considerations, PL/I<br/></p>
<p>sharing files, PL/I and C 57<br/>writing files, multiple programs 57<br/></p>
<p>icdata operand 218<br/>icdatlen operand 218<br/>icname operand 218<br/>IDATAQ access queue<br/></p>
<p>description 61, 207<br/>usage 103, 184<br/></p>
<p>IEL0872I message 53<br/>IFRAUGMT, CNMGETA attribute 195<br/>IFRAUI3X, CNMGETA attribute 196<br/>IFRAUIN3, CNMGETA attribute 196<br/>IFRAUIND, CNMGETA attribute 195<br/>IFRAUSB2, CNMGETA attribute 196<br/>IFRAUSC2, CNMGETA attribute 196<br/>IFRAUSRB, CNMGETA attribute 196<br/>IFRAUSRC, CNMGETA attribute 196<br/>IFRAUTA1, CNMGETA attribute 196<br/>IFRAUWF1, CNMGETA attribute 197<br/>iiname operand 222<br/>iinumb operand 224<br/>immediate command 58, 115, 188<br/>include files - C 112, 279<br/>include files - PL/I 55, 269<br/>information retrieval<br/></p>
<p>C 69<br/>PL/I 129<br/></p>
<p>initial command 15<br/>initial data queue (IDATAQ) 103<br/>initial operands, PL/I 49<br/>initial parameters - C 103<br/>input before command processing 13<br/>input from the operator 14<br/>input from the system console 17<br/>input, line mode 4<br/>input/output considerations<br/></p>
<p>full-screen 4<br/>preinitialized environments 57<br/></p>
<p>installation exits 13<br/>C coding 103<br/>coding 11, 152<br/>coding restrictions 11<br/>deleting messages 12<br/>described 11<br/>descriptions 13<br/></p>
<p>alert generation exit routine 14<br/>before logging off 13, 19<br/>before VTAM command invocation 13, 16<br/>BSAM empty file 13, 21<br/>BSAM output 14, 22<br/>CNM input 14, 22<br/>CNM interface output 14, 24<br/>cross-domain command send 13, 17<br/>DST initialization 14, 25<br/>encryption key for DSITCPRF 21<br/>external logging 14, 26<br/>input before command processing 13<br/>input, command processing 15<br/>input, operator 14<br/>input, system console 13, 17<br/>log output 13, 15<br/></p>
<p>installation exits <i>(continued)<br/></i>descriptions <i>(continued)<br/></i></p>
<p>logon validation 13, 18<br/>message output, cross-domain 13<br/>message output, this domain 13<br/>OST/NNT message receiver 13, 19<br/>output, operator 14<br/>output, system console 13, 17<br/>RUNCMD authorization 13, 20<br/>SAW filtering 21<br/>solicited VTAM messages 13, 16<br/>unsolicited VTAM messages 13, 17<br/>VSAM empty file 14, 25<br/>VSAM input 14, 25<br/>VSAM output 14, 26<br/></p>
<p>DST<br/>C 151<br/>PL/I 85<br/></p>
<p>for HLL 11<br/>general return codes 12<br/>names 13<br/></p>
<p>BNJPALEX 13, 14<br/>DSIEX01 13, 14<br/>DSIEX02A 13, 14<br/>DSIEX03 13, 15<br/>DSIEX04 13, 15<br/>DSIEX05 13, 16<br/>DSIEX06 13, 16<br/>DSIEX07 13, 17<br/>DSIEX09 13, 17<br/>DSIEX10 13, 17<br/>DSIEX11 13, 17<br/>DSIEX12 13, 18<br/>DSIEX13 13, 19<br/>DSIEX14 13, 19<br/>DSIEX16 13, 20<br/>DSIEX16B 13, 20<br/>DSIEX17 13, 20<br/>DSIEX18 13, 20<br/>DSIEX19 13, 20<br/>DSIEX20 13, 21<br/>DSIEX21 13, 21<br/>XITBN 13, 21<br/>XITBO 14, 22<br/>XITCI 14, 22<br/>XITCO 14, 24<br/>XITDI 14, 25<br/>XITVI 14, 25<br/>XITVN 14, 25<br/>XITVO 14, 26<br/>XITXL 14, 26<br/></p>
<p>non-preinitialized environments, steps for<br/>implementing 34<br/></p>
<p>overview 11<br/>performance degradation 12<br/>PL/I coding 86<br/>PL/I support 49<br/>preinitialized environments, steps for implementing 34<br/>replacing messages 12<br/></p>
<p>integer variable, PL/I example 53<br/>integer variables 53, 107<br/>interfaces<br/></p>
<p>C program 103<br/>PL/I program 49<br/></p>
<p>internal function request (IFR) 19<br/>interruption request block (IRB) exit 11<br/></p>
<p>Index <b>297</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>invoking synchronous commands<br/>C example 123<br/>PL/I example 65<br/></p>
<p>IPV6 219<br/>IPv6Env statement 219<br/>IRB (interruption request block) exit 11<br/>ISASIZ PL/I runtime option<br/></p>
<p>displayed by RID 170<br/>istring operand 111, 112<br/></p>
<p><b>J<br/></b>JOBNAME, CNMGETA attribute 197<br/>JOBNUM, CNMGETA attribute 197<br/></p>
<p><b>K<br/></b>key-sequenced data set (KSDS) 25<br/>key-sequenced VSAM files 227<br/>KEY, CNMGETA attribute 198<br/>keyed file access<br/></p>
<p>C example 149<br/>PL/I example 83<br/>under a DST 227<br/></p>
<p>keyword authorization checking 249<br/></p>
<p><b>L<br/></b>label line message 252<br/>LEOPTS static external variable 51, 105<br/>line mode<br/></p>
<p>input 4<br/>link-edit<br/></p>
<p>JCL 43<br/>PL/I program 43<br/></p>
<p>lkfunc operand 230<br/>lkname operand 230<br/>lkoption operand 230<br/>lkscope operand 230<br/>local pool 264<br/>lock management<br/></p>
<p>C example 133<br/>controlling 229<br/>PL/I example 71<br/>user-defined locks 7<br/></p>
<p>log output 15<br/>logging messages 8<br/>logical unit name 219<br/>LOGOFF command 19<br/>LOGOFF routine 223<br/>logon validation 13, 18<br/>long-running command 187<br/>LOSTERM exit 19<br/>LU 219<br/>LU 6.2 transport 6, 215, 258<br/></p>
<p><b>M<br/></b>MACRF keyword 29<br/>main function in C 103<br/>major vector key 23<br/>management services (MS) transport 6<br/>manuals<br/></p>
<p>see publications xiii<br/>MCGASID, CNMGETA attribute 198<br/></p>
<p>MCSFLAG, CNMGETA attribute 198<br/>mctoken operand 231<br/>MDB<br/></p>
<p>C example 162<br/>PL/I example 97<br/>processing 236<br/></p>
<p>mdb operand 237<br/>MDS-MUs 5<br/>MDSMU keyword<br/></p>
<p>CNMHSMU statement 214<br/>CNMSMU statement 254<br/></p>
<p>MDSMUQ access queue 61, 121, 207<br/>member name 232<br/>message identifier 207<br/>message receiver 19<br/>message text 207<br/>messages<br/></p>
<p>automation 4, 14<br/>buffer, sending copies 17<br/>change VTAM message 16<br/>editing system console 17<br/>logging 8<br/>multiline 4, 74<br/>NetView, automating 4<br/>processing, C example 137<br/>processing, PL/I example 74<br/>replace 12, 14<br/>send to a specific log 15<br/>sending a single unit 4<br/>sending with C 122<br/>sending, PL/I 61<br/>suppress logging 15<br/>trapping 4<br/>using 12<br/></p>
<p>messages (event type) 182<br/>MLWTO 4<br/>moddname operand 232<br/>momemnam operand 232<br/>monitor cross-domain traffic 17<br/>motoken operand 232<br/>mrdata operand 233<br/>mrdatlen operand 233<br/>mrinclude operand 233<br/>mrtoken operand 234<br/>MS Applications 6<br/>MS transport<br/></p>
<p>registering applications<br/>C example 158<br/>PL/I example 92<br/></p>
<p>sending alerts<br/>C example 160<br/>PL/I example 95<br/></p>
<p>MS transport layer 6<br/>MSGAUTH, CNMGETA attribute 198<br/>MSGCATTR, CNMGETA attribute 198<br/>MSGCBGPA, CNMGETA attribute 200<br/>MSGCMISC, CNMGETA attribute 198<br/>MSGCMLVL, CNMGETA attribute 199<br/>MSGCMSGT, CNMGETA attribute 199<br/>MSGCOJBN, CNMGETA attribute 199<br/>MSGCPROD, CNMGETA attribute 199<br/>MSGCSPLX, CNMGETA attribute 200<br/>MSGCSYID, CNMGETA attribute 200<br/>MSGDOMFL, CNMGETA attribute 200<br/>MSGGDATE, CNMGETA attribute 200<br/>MSGGFGPA, CNMGETA attribute 201<br/>MSGGMFLG, CNMGETA attribute 201<br/></p>


</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>MSGGMID, CNMGETA attribute 201<br/>MSGGSEQ, CNMGETA attribute 201<br/>MSGGSYID, CNMGETA attribute 201<br/>MSGGTIME, CNMGETA attribute 201<br/>MSGSRCNM, CNMGETA attribute 201<br/>MSGSRCOB, CNMGETA attribute 202<br/>MSGTOKEN, CNMGETA attribute 202<br/>MSGTSTMP, CNMGETA attribute 202<br/>MSGTYP, CNMGETA attribute 202<br/>MSU automating<br/></p>
<p>C example 157<br/>PL/I example 90<br/></p>
<p>multiline messages 4, 137, 205<br/>MVS console 18<br/>MVS console operator task 18<br/>MVS JOB name/number 197<br/>MVS system 204<br/>MVS system log 15<br/>MVSLEVEL 219<br/>MVTUFLD control block 223<br/></p>
<p><b>N<br/></b>n type specifier 247<br/>named storage 7, 234<br/>NETID 219<br/>NetView<br/></p>
<p>data sets 80, 144<br/>domain ID (DOMAIN) 218<br/>information query 5<br/>invoking HLL commands 3<br/>message type 207<br/>partitioned data sets 7<br/>start time (STARTTIME) 220<br/>version and release (NVVER) 219<br/></p>
<p>NetView automation table 4<br/>NetView Bridge access 8<br/>NetView command list language 62, 264<br/>NetView command list language variables<br/></p>
<p>&amp;HDRMTYPE 204<br/>&amp;LINETYPE 204<br/>&amp;MSGID 204<br/>&amp;MSGORIGIN 204, 207<br/></p>
<p>NetView message automation 4<br/>NetView partitioned data sets, read access from HLL 7<br/>NetView tasks 13<br/>network log 15, 251<br/>network services request units 22<br/>NEVDELID, CNMGETA attribute 203<br/>new password function 18<br/>NMVT request 22<br/>NNT task 13, 18<br/>NOHEXCNV constant 111, 112<br/>non-cancelable, defining programs 39<br/>non-preinitialized environments 33<br/></p>
<p>advantages and disadvantages 33<br/>command processors, steps for implementing 34<br/>examples 41<br/>HLL definition facilities 35<br/>HLL definition facilities, interface modules 36<br/>installation exits, steps for implementing 34<br/>PL/I runtime options<br/></p>
<p>entry points 50<br/>specifying 50<br/></p>
<p>storage values for 50<br/>NONMDSMU keyword<br/></p>
<p>CNMHSMU statement 214<br/></p>
<p>NONMDSMU keyword <i>(continued)<br/></i>CNMSMU statement 254<br/></p>
<p>NOSPIE runtime option<br/>C program 103, 113, 114<br/></p>
<p>NOSTAE runtime option<br/>C program 103, 114<br/></p>
<p>notation<br/>environment variables xix<br/>path names xix<br/>typeface xix<br/></p>
<p>nsclass operand 235<br/>nsfunc operand 235<br/>nsleng operand 235<br/>nsname operand 235<br/>nsptr operand 235<br/>null terminator (\0) 108, 110, 111<br/>NV 219<br/>NVVER 219<br/></p>
<p><b>O<br/></b>ON FIXEDOVERFLOW, avoiding 58<br/>ON OVERFLOW, avoiding 58<br/>ON UNDEFINEDFILE statement 56<br/>ON UNDERFLOW, avoiding 58<br/>ON ZERODIVIDE, avoiding 58<br/>online publications<br/></p>
<p>accessing xvi<br/>open capability 80, 144<br/>operands passed to HLL service routines<br/></p>
<p>fixed-length character strings 54, 108<br/>integer variables 53, 107<br/>pointer variables 52, 106<br/>varying length characters 54, 108<br/></p>
<p>operating remote systems 6<br/>operating system 220<br/>operations management<br/></p>
<p>registering applications<br/>C example 158<br/>PL/I example 92<br/></p>
<p>transport layer 6<br/>operator<br/></p>
<p>full-screen input/output 4<br/>GO command 4<br/>ID 219, 249<br/>ID name (function) 18<br/>input 182<br/>input queue (OPERQ) 61, 121, 207<br/>input to a command procedure 4<br/>interaction 3<br/>LU name (function) 18<br/>station tasks (OST) 65, 123<br/>terminal 219<br/></p>
<p>operator input<br/>C example 134<br/>PL/I example 72<br/></p>
<p>operators in group 251<br/>OPERQ input queue 61, 121, 207<br/>OPID 219<br/>OPINPUT wait command 177<br/>OPSYSTEM 220<br/>options, runtime<br/></p>
<p>default values 38<br/>specifying HLLOPTS 50<br/>specifying, HLLOPTS 38<br/></p>
<p>origappl operand 214<br/>Origblck initial parameter, C program 103<br/></p>
<p>Index <b>299</b></p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>ORIGBLCK initial parameter, PL/I program 49<br/>origin blocks 108<br/>origin of request, Origblck 103<br/>OST (operator station task) 13, 18<br/>OST/NNT message receiver 19<br/>output<br/></p>
<p>operator 14<br/>system console 17<br/></p>
<p>OVERRIDE command options, DSIEX02A 14<br/>OWNER 220<br/></p>
<p><b>P<br/></b>PACTLU (CNMS4218) PL/I sample 274<br/>PACTPIP (CNMS4305) PL/I sample 67, 277<br/>pafld1,...pafld10 operand 246<br/>panumfld operand 246<br/>parameters passed to HLL service routines<br/></p>
<p>C 105<br/>PL/I 51<br/></p>
<p>parsing character strings 7, 62, 246<br/>PARTID, CNMGETA attribute 203<br/>partitioned data sets 7, 231, 232<br/>password function 18<br/>pastring operand 247<br/>path names, notation xix<br/>pattern operand 247<br/>PAUTOTB (CNMS4231) PL/I sample 275<br/>pcfunc operand 186<br/>PCNMI (CNMS4214) PL/I sample 273<br/>pcstrptr operand 186<br/>pctoken operand 186<br/>PDDNM keyword 29<br/>PDOVSAM (CNMS4223) PL/I sample 14, 275<br/>performance considerations, PL/I and C installation exits 12<br/>PEXIT2A (CNMS4213) PL/I sample 13, 273<br/>PEXIT3 (CNMS4210) PL/I sample 13, 272<br/>PFLVIEW (CNMS4217) PL/I sample 274<br/>PHREGSTR (CNMS4236) PL/I sample 276<br/>PHSNDMU (CNMS4226) PL/I sample 275<br/>PID 220<br/>PIPE command<br/></p>
<p>C examples<br/>accessing stem variables 131<br/>trapping messages 125<br/></p>
<p>description 177<br/>online help 178<br/>PL/I examples<br/></p>
<p>accessing stem variables 70<br/>trapping messages 67<br/></p>
<p>PKEYIO (CNMS4215) PL/I sample 273<br/>PL/I<br/></p>
<p>control blocks 55<br/>DSIPHLB 55<br/>INCLUDE files 55<br/>preinitialized environment<br/></p>
<p>runtime options automatically set 50<br/>runtime options<br/></p>
<p>TRAP(OFF) 57<br/>TRAP(ON) 57<br/></p>
<p>PL/I command processors, support for 49<br/>PL/I examples<br/></p>
<p>access command list variables 70<br/>altering data 78<br/>CNMI 81<br/>code points, translating 91<br/>coding template 59<br/></p>
<p>PL/I examples <i>(continued)<br/></i>coding, DST installation exit 85<br/>coding, installation exit 86<br/>coding, WAIT FOR DATA 87<br/>command authorization checking 75<br/>data set access 80<br/>high-performance transport 96<br/>HLBRC field 12<br/>invoking synchronous commands 65<br/>keyed file access 83<br/>MDB, sending to NetView 97<br/>message processing 74<br/>MS transport 95<br/>MSUs, automating 90<br/>operator input 72<br/>overriding PSTACK and PHEAP values 51<br/>parsing character strings<br/></p>
<p>CNMSCAN 63<br/>NetView 62<br/>REXX 63<br/></p>
<p>registering applications<br/>high-performance transport 94<br/>MS transport 92<br/>operations management 92<br/></p>
<p>retrieving information 69<br/>sending commands 65<br/>sending messages 61<br/>storage access 79<br/>using locks 71<br/>VIEW command processor 73<br/>VSAM access 83<br/>waiting and trapping 66<br/></p>
<p>PL/I high-level language services 59<br/>PL/I include files<br/></p>
<p>description 55<br/>DSIPCNM 56, 269<br/>DSIPCONS 55, 269<br/>DSIPHLB 55, 269<br/>DSIPHLLS 56, 269<br/>DSIPLI 55, 269<br/>DSIPORIG 55, 269<br/>DSIPPRM 56, 269<br/></p>
<p>PL/I INCLUDE files, optional<br/>DSIPCNM 56<br/>DSIPCONS 55<br/></p>
<p>PL/I INCLUDE files, required<br/>DSIPHLLS 56<br/>DSIPLI 55<br/>DSIPORIG 55<br/>DSIPPRM 56<br/></p>
<p>PL/I installation exits, support for 49<br/>PL/I program<br/></p>
<p>coding template 59<br/>commands to avoid<br/></p>
<p>DELAY 58<br/>DISPLAY 58<br/>ON FIXEDOVERFLOW 58<br/>ON OVERFLOW 58<br/>ON UNDERFLOW 58<br/>ON ZERODIVIDE 58<br/>PLIRETC 58<br/>PLIRETV 58<br/>WAIT 58<br/></p>
<p>compiling 43<br/>ending normally 58<br/>environment 49<br/>file I/O capability 56<br/></p>


</div></div>
</body></html>